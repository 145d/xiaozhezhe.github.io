<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.zhz666.cf</id>
    <title>欢迎来到德莱联盟</title>
    <updated>2021-03-23T13:25:11.716Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.zhz666.cf"/>
    <link rel="self" href="https://www.zhz666.cf/atom.xml"/>
    <subtitle>笑着面对生活，爱你呦~</subtitle>
    <logo>https://www.zhz666.cf/images/avatar.png</logo>
    <icon>https://www.zhz666.cf/favicon.ico</icon>
    <rights>All rights reserved 2021, 欢迎来到德莱联盟</rights>
    <entry>
        <title type="html"><![CDATA[GlusterFS分布式文件系统]]></title>
        <id>https://www.zhz666.cf/post/glusterfs-fen-bu-shi-wen-jian-xi-tong/</id>
        <link href="https://www.zhz666.cf/post/glusterfs-fen-bu-shi-wen-jian-xi-tong/">
        </link>
        <updated>2021-03-19T02:58:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="理论">理论：😋</h2>
<p><code>1、分布式文件系统</code><br>
互联网应用技术的高速发展，网络时代由IT时代进入了DT时代。IT信息技术，DT数据技术。进入大数据时代，导致互联网应用后台无法快速有效的记录存储数据。</p>
<p>分布式：将数据或文件存放在不同的服务器上，访问时，同时对多台服务器进行数据读取。如DNS服务</p>
<p><code>2、主流的分布式文件系统</code></p>
<p>Ceph	发布与开源社区，云计算和存储厂商支持的比较多。<br>
HDFS	（Hadoop Distributed File System），是Hadoop的一个核心<br>
Swift	Swift 最初是由Rackspace公司开发的分布式对象存储服务， 2010 年贡献给 OpenStack 开源社区。</p>
<p>GFS	google的分布式文件存储系统，是专为存储海量搜索数据而设计的。google和baidu是同一时期进入中国的。安卓系统，量子计算机，人工智能。</p>
<p>Luster	基于linux内核开发的分布式文件系统，开源，注意应用与HPC（手持PC,平板电脑，PAD等设备）</p>
<p>GlusterFS	开源软件，实现过程与工作结构比较简单，高效的文件系统。发</p>
<p>MFS	早期的一种分布式文件系统</p>
<h2 id="分布式文件系统工作原理">分布式文件系统工作原理</h2>
<p><code>1、MFS工作原理</code><br>
通过拓扑图，查看基本结构：<br>
MFS文件系统是一种中心结构型的文件系统，客户端访问数据时，将请求发送给中心节点(调度器)，中心节点进行查询匹配后，进行存储服务器的调度。<br>
元数据服务器：master，是一个调度器，用于接收客户端访问请求，并进行存储服务器的调度。元数据管理，有点像图书管理员的查询目录。<br>
元数据日志服务器：metalogger server ,是元数据服务器的备份服务器，以日志文件管理的方式，备份master的动作变化。<br>
数据存储服务器：chunk server，存储节点服务器，是用来存储实体数据。<br>
客户端：client，通过挂载使用MFS的主机。</p>
<p><code>2、MFS的工作原理</code><br>
1.读取数据</p>
<p>客户端给元数据服务器发送读取文件请求。<br>
元数据服务器通过文件列表查询，找到文件存储位置和信息。<br>
将存储位置和信息发送给客户端。<br>
客户端收到信息后，通过信息描述的位置访问数据存储服务器。<br>
数据存储服务器收到请求后，将数据发送给客户端，完成读取任务。</p>
<p>2.写入数据</p>
<p>客户端给元数据服务器发送写入文件请求和文件基本信息。<br>
·元数据服务器收到请求后，给所有的存储服务器发送存储通告。<br>
存储服务器收到通告后，回应是否有空闲和存储区域信息。<br>
·元数据服务器收到通告回应后，将存储服务器地址和存储区域信息发送给客户端。↓<br>
客户端收到存储区域信息后，访问存储服务器，并进行数据保存。<br>
客户端数据保存完成后，给元数据服务器发送存储完成的响应。↓<br>
存储服务器存储完成后，也给元数据服务器发送完成响应。<br>
·元数据服务器收到响应后，完成文件管理列表，并将动作写入日志和日志服务器。↑</p>
<p><code>3、GlusterFS文件系统工作原理</code><br>
GlusterFS采用可堆叠的用户空间设计。<br>
glusterfs是一个无中心结构的开源分布式文件系统，使用存储卷和组合存储卷的方式进行工作，部分功能和协议参照应用了磁盘整列的功能。</p>
<p><strong>1.GlusterFS的特点：</strong></p>
<p>扩展性：支持的功能和软件比较多。对linux平台的兼容性高。</p>
<p>高性能：能够支持高速读写，和高并发访问。</p>
<p>高可用性：能够支持冗余。</p>
<p>全局同一命名空间：多台服务器构建存储群集后，使用同一个虚拟服务器名。</p>
<p>弹性卷管理：支持存储系统的服务器扩展，能够添加服务器。</p>
<p>标准协议：共享协议使用NFS和SMB，数据传输协议使用CIFS等，连接使用TCP/IP协议。兼容性高。</p>
<p><strong>2.GlusterFS的专业名词术语：</strong></p>
<p>brick	：存储块，对数据进行基本存储的物理分区  /dev/sdb1  /dev/sdc1   /data</p>
<p>volume	：逻辑卷，多个物理存储分区的集合（多个存储块组合成一个整体的逻辑存储设备）</p>
<p>FUSE	：内核模块，用于创建和管理文件系统。（在服务器之间建立存储关系）</p>
<p>VFS	：内核模块，内核空间对用户空间提供的一个访问磁盘的接口。</p>
<p>Glusted	：是一个文件系统管理器，在每个节点服务器上运行，节点服务器通过glusted管理器相互确认身份，交换存储信息。（后台管理进程，处理用户的访问请求，查询存储列表）<br>
--以上是glusterfs堆载式结果</p>
<p><strong>3.GlusterFS的工作原理：</strong></p>
<p>客户端的应用程序通过挂载点发送访问请求。<br>
客户端的操作系统内核VFS接收并处理请求，将访问发送给FUSE内核进程。<br>
客户端的FUSE内核进程通过设备将请求发送给GlusterFS客户端进程。<br>
GlusterFS客户端进程通过配置，对数据进行读或写的处理，将数据发送给GlusterFS服务器。<br>
GlusterFS服务器收到数据后，通过VFS接口连接文件系统，进行数据的读取或访问，将结果返回客户端。</p>
<p><strong>4.服务器存储数据的方式：</strong></p>
<p>将数据分割成块。<br>
使用hash算法计算哈希值（32位）。<br>
给每个数据块添加一个值。<br>
将存储空间分为N个存储区。<br>
将数据库按规则存储在存储区中。</p>
<p>哈希值的作用：<br>
不会产生重复的文件块编号，防止分块存储是出错。<br>
当有重复的文件时，不会重复存储，产生空间浪费。</p>
<h2 id="glusterfs部署">GlusterFS部署</h2>
<p>1、安装配置GlusterFS节点服务器<br>
四台node节点，1台客户端</p>
<p>1.配置节点服务器ip地址<br>
2.修改节点服务器的计算机名<br>
3.配置hosts文件（4台节点相同）<br>
[root@localhost ~]# hostname node1<br>
[root@localhost ~]# bash<br>
[root@node1 ~]# vim /etc/hosts<br>
添加：<br>
192.168.10.1 node1<br>
192.168.10.2 node2<br>
192.168.10.3 node3<br>
192.168.10.4 node4</p>
<p>4.安装软件（在所有节点上安装）<br>
复制GlusterFS软件包到/media目录中，再进行安装。如果在使用yum安装时报错，输入清除yum缓存的命令。<br>
yum  clean all<br>
配置本地yum源<br>
[root@node1 ~]# yum -y install glusterfs glusterfs-server glusterfs-fuse glusterfs-rdma</p>
<p>5.启动glusterd服务<br>
systemctl  restart glusterd</p>
<p>6.建立存储群集<br>
在任意一台节点上建立群集，只需要操作一次。<br>
[root@node1 ~]# gluster peer probe node1<br>
[root@node1 ~]# gluster peer probe node2<br>
[root@node1 ~]# gluster peer probe node3<br>
[root@node1 ~]# gluster peer probe node4</p>
<p>7.查看状态<br>
[root@node1 ~]# gluster peer status</p>
<p><code>2、创建分布式文件系统</code></p>
<p>在所有节点服务器上创建分布式文件系统的存储目录</p>
<p>mkdir /data1 /data2 /data3</p>
<p>1.分布式卷（Distributed Volume）<br>
又称哈希卷，类似于RAID0。是GlusterFS中三大基本卷之一，应用率比较高。分布式卷对文件进行处理，没有分块，通过文件扩展属性生成hash值，分散存储在节点上，对存储效率没有提升，但是能够提高并发访问量。</p>
<p>工作原理：<br>
客户端给分布式卷发送写入请求：<br>
分布式卷收到客户端的写入请求后，记录文件的相关信息，生成hash值。<br>
分布式卷对存储节点服务器发送写入通告。<br>
分布式卷收到最先响应的节点回应后，将写入请求发送给该节点进行存储。</p>
<p>客户端给分布式卷发送读取请求：<br>
分布式卷收到请求后，对文件信息进行对比验证，找到存储节点。<br>
将读取请求发送给节点服务器，读取文件。</p>
<p>创建分布式卷（在node1操作）：<br>
使用node1和node2节点配置分布式卷：<br>
[root@node1 /]# gluster volume create dis-volume  node1:/data1 node2:/data1 force<br>
卷 创建  卷名(自定义)  节点计算机名:/目录名</p>
<p>查看分布式卷信息：<br>
[root@node1 /]# gluster volume info dis-volume</p>
<p>启用分布式卷：<br>
[root@node1 /]# gluster volume start dis-volume</p>
<p>查看分布式卷状态：<br>
[root@node1 /]# gluster volume status dis-volume<br>
优点：容量大；缺点：没冗余</p>
<p>2.客户端应用：</p>
<p>安装客户端<br>
配置客户端IP地址<br>
配置客户端hosts文件<br>
vim /etc/hosts<br>
添加：<br>
192.168.10.1 node1<br>
192.168.10.2 node2</p>
<p>安装GlusterFS客户端</p>
<p>[root@localhost /]# yum -y install glusterfs glusterfs-fuse</p>
<p>创建挂载点目录：</p>
<p>[root@localhost /]# mkdir -p /{dis,stripe,rep,dis-stripe,dis-rep}</p>
<p>挂载分布式文件系统：</p>
<p>[root@localhost /]# mount -t glusterfs node1:dis-volume /dis</p>
<p>3、分布式文件系统的优缺点：<br>
1.提高了文件系统的并发访问量。<br>
2.因为是单服务器节点存储数据，所以对数据的存储效率没有提升。<br>
3.任意节点损坏，分布式系统还能使用，但会丢失部分数据，没有数据冗余性。</p>
<pre><code>GlusterFS文件系统（2）
</code></pre>
<p>--<br>
【1】条带卷（Striped Volume）<br>
相当于raid0，文件是分片均匀写在各个节点的硬盘上的。优点是分布式读写,性能整体较好。缺点是没冗余,分片随机读写可能会导致硬盘IOPS饱和。<br>
写入数据：<br>
当条带卷接收到客户端的写入请求后，将数据按照节点服务器的数量进行分段，在文件信息中添加分段偏移量信息。将分好段的数据分别保存在每个节点服务器上。</p>
<p>读取数据：<br>
当条带卷接收到客户端的读取请求后，根据文件信息中的分段信息，同时从各个节点上读取数据，根据偏移量信息在内存中进行文件的合并。</p>
<p>特点：条带卷具有高速读写的性能，理论分析中（不考虑其他干扰因素和故障冗余问题），节点的数量越多，读写性能越高,写入速度也就越快。<br>
缺点：不具备故障冗余功能，任何一台节点服务器断线或出现故障，则整个条带卷就会出现故障。无法提供工作。</p>
<p>--配置条带卷</p>
<pre><code>     	卷      创建   卷名(自定义)    卷类型(条带) 数据分段数量   节点链接方式  TCP协议  
</code></pre>
<p>gluster volume create stripe-volume   stripe               2               transport   tcp    node1:/data2 node2:/data2 force</p>
<p>启动条带卷：<br>
gluster volume start stripe-volume</p>
<p>查看条带卷信息：<br>
gluster volume info stripe-volume</p>
<p>客户端挂载：<br>
mount -t glusterfs node1:/stripe-volume /stripe</p>
<p>客户端写入测试：<br>
cd /stripe<br>
dd if=/dev/zero of=stripe.iso bs=1M count=100</p>
<p>【2】复制卷</p>
<p>功能类似于磁盘整列RAID1，可以由多台节点服务器构建，同一个文件可以保存一份或多份。由一台节点服务器面向客户端响应工作，其他服务器都是镜像服务器。提供文件系统的冗余性，但不是备份。主服务上删除文件时，冗余服务器上也会删除文件。（通常与分布式卷或者条带卷组合使用,解决前两种存储卷的冗余缺陷。缺点是磁盘利用率低。）</p>
<p>特点：<br>
提供冗余功能，服务器的存储空间利用率比较低。读写性能相对较弱，因为有数据同步的时间。如果构成复制卷的多个节点存储空间不同的话，按最少的空间为基准。</p>
<p>--配置复制卷</p>
<p>创建复制卷：<br>
gluster volume create rep-volume replica 2 transport tcp node1:/data3 node2:/data3 force</p>
<p>启动复制卷：<br>
gluster volume start rep-volume</p>
<p>查看复制卷信息：<br>
gluster volume info rep-volume</p>
<p>客户端挂载：<br>
mount -t glusterfs node1:/rep-volume /rep</p>
<h2 id="测试cd-repdd-ifdevzero-ofrepiso-bs1m-count100">测试：<br>
cd /rep<br>
dd if=/dev/zero of=rep.iso bs=1M count=100</h2>
<pre><code>GlusterFS文件系统（3）
</code></pre>
<p>【1】分布式条带卷<br>
分布式条带卷是存储群集中的一种组合应用方式，按照常规的层次结构，分布式卷在群集结构中的最上层，中层有两个条带卷构成，下层分别有多台节点服务器构成两个条带卷。</p>
<p>当分布式卷收到客户端的访问请求后，根据分布式卷的调度规则，将请求转发给其中一个条带卷，条带卷收到访问请求后，对需要写入的数据进行分段处理，并发送给每个节点服务器。</p>
<p>--配置分布式条带卷<br>
创建分布式条带卷：<br>
gluster volume create dis-stripe stripe 2 node1:/data4 node2:/data4 node3:/data4 node4:/data4 force</p>
<p>启动分布式条带卷：<br>
gluster volume start dis-stripe<br>
查看分布式条带卷信息：<br>
gluster volume info dis-stripe<br>
客户端挂载：<br>
mount -t glusterfs node1:/dis-stripe /dis-stripe</p>
<p>【2】分布式复制卷<br>
对客户端发送的写入请求进行分布式调度存储，并对每个节点服务器进行复制卷冗余。在生产环境中应用率不太高。</p>
<p>--配置分布式复制卷：<br>
gluster volume create dis-rep replica 2 node1:/data5 node2:/data5 node3:/data5 node4:/data5 force</p>
<p>启动分布式条带卷：<br>
gluster volume start dis-rep<br>
查看分布式条带卷信息：<br>
gluster volume info dis-rep<br>
客户端挂载：<br>
mount -t glusterfs node1:/dis-rep /dis-rep</p>
<p>【3】条带复制卷<br>
条带卷收到写入请求后，将数据进行分段，分别发送给两个复制卷，由复制卷写入数据后进行数据同步到冗余设备中。（将两个复制卷合并成一个条带卷,提供读写性能和冗余性）</p>
<p>--配置条带复制卷：<br>
gluster volume create stripe-rep stripe 2 replica 2 node1:/data6 node2:/data6 node3:/data6 node4:/data6 force</p>
<p>启动条带复制卷：<br>
gluster volume start stripe-rep<br>
查看条带复制卷信息：<br>
gluster volume info stripe-rep<br>
客户端挂载：<br>
mount -t glusterfs node1:/stripe-rep /stripe-rep</p>
<p>【4】复制条带卷<br>
复制卷收到写入请求后，将数据发送给主条带卷，主条带卷将数据进行分段，分别写入节点设备，主条带卷写入完成后，将数据发送给冗余条带卷，冗余条带卷收到数据后进行分段，并写入节点服务器。</p>
<p>--配置复制条带卷：<br>
gluster volume create rep-stripe  replica 2 stripe 2 node1:/data7 node2:/data7 node3:/data7 node4:/data7 force</p>
<p>启动复制条带卷：<br>
gluster volume start rep-stripe<br>
查看复制条带卷信息：<br>
gluster volume info rep-stripe<br>
客户端挂载：<br>
mount -t glusterfs node1:/rep-stripe /rep-stripe</p>
<p>【5】分布式条带复制卷</p>
<p>最少有8台节点服务器构成，底层由8台节点构建4个复制卷，由4个复制卷构建2个条带卷，最上层有两个条带卷构建一个分布式卷。</p>
<h2 id="在最上层提高了访问并发量中层提高了读写性能底层提高了冗余性">在最上层提高了访问并发量，中层提高了读写性能，底层提高了冗余性。</h2>
<pre><code>GlusterFS集群故障测试与修复
</code></pre>
<p><code>1、故障冗余测试</code></p>
<p>断开node2节点服务器的网络，在客户端上查看与使用文件系统，测试不同卷的工作状态：<br>
结果：<br>
1.分布式卷：能够继续使用，但丢失了一部分数据。读写功能正常。<br>
2.条带卷：已挂载的卷能够打开，但是没有任何数据。无法写入数据。<br>
3.复制卷：能够正常使用卷，没有丢失数据，读写功能正常。<br>
4.分布式条带卷：能够继续使用，丢失了一部分数据，读取正常，也能够继续写入数据。<br>
5.分布式复制卷：能够正常使用，没有丢失数据，读写功能正常。<br>
6.条带复制卷：能够正常使用，没有丢失数据，读写功能正常。<br>
7.复制条带卷：能够正常使用，没有丢失数据，读写功能正常。</p>
<p><code>2、配置分布式条带复制卷</code></p>
<p>gluster volume create dis-stripe-rep stripe 2 replica 2 node1:/data8 node2:/data8 node3:/data8 node4:/data8 node5:/data8 node6:/data8 node7:/data8 node8:/data8 force</p>
<p>启动分布式条带复制卷<br>
gluster volume start dis-stripe-rep</p>
<p>查看分布式条带复制卷信息：<br>
gluster volume info dis-stripe-rep</p>
<p><code>3、停止卷</code></p>
<p>1.客户端卸载需要停止的卷</p>
<p>2.在构建卷的节点服务器上输入停止卷的命令</p>
<p>gluster volume stop dis-volume</p>
<p><code>3.删除指定的卷</code></p>
<p>gluster volume delete dis-volume</p>
<p>注意事项：正在被挂载的卷无法停止，没有停止的卷无法删除，删除的卷不可恢复，只能重新创建。源条带卷节点服务器会保留被分段的文件。重新创建条带卷后，文件可以正常使用。</p>
<p><code>4、GlusterFS其他相关命令</code><br>
-1.查看glusterfs卷列表（任意节点上）：<br>
[root@node1 /]# gluster volume list</p>
<p>-2.查看所有卷信息（任意节点上）：<br>
[root@node4 /]# gluster volume info</p>
<p>-3.查看卷状态（任意节点上）：<br>
[root@node4 /]# gluster volume status</p>
<p>-4.停止或删除卷<br>
[root@node4 /]# gluster volume stop dis-volume<br>
删除卷时，需要先停止卷，再删除。<br>
[root@node4 /]# gluster volume delete dis-volume</p>
<p>-5.设置卷访问控制<br>
gluster volume set 卷名 auth.allow 192.168.10.10,192.168.20.*</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iptables与fiewalld防火墙]]></title>
        <id>https://www.zhz666.cf/post/iptables-yu-fiewalld-fang-huo-qiang/</id>
        <link href="https://www.zhz666.cf/post/iptables-yu-fiewalld-fang-huo-qiang/">
        </link>
        <updated>2021-01-01T04:25:45.000Z</updated>
        <content type="html"><![CDATA[<p>寄居架构：安装在操作系统之上，操作系统死亡，软件随之毁灭。抢夺操作系统的资源<br>
原生架构：直接安装在硬件之上，本身就属于一款操作系统。可以随时分配调节系统资源</p>
<p>OSI 7层<br>
应用层：操作系统之上<br>
表示层<br>
会话层<br>
传输层<br>
网络层<br>
数据链路层<br>
物理层</p>
<p><font color="#660000" size=5>【1】防火墙相关知识</font><br>
软件级（类似于寄居架构）：安装在操作系统之上的一个防火墙软件。<br>
优点：<br>
工作在应用层，功能强大。可以针对IP地址进行过滤，还可以针对用户名进行过滤，组进行过滤。<br>
缺点：<br>
工作在应用层，代理级的。对包的执行效率非常低。兼容性问题。安全漏洞问题。（后期的软件防火墙大部分用于“本地主机保护”）<br>
常见的软件防火墙：<br>
Windows：ISA 2012		天网		系统本身自带：Linux：iptables	firewalld</p>
<h2 id="硬件级类似于原生架构独立硬件嵌入式应用程序-这个操作系统本身就是防火墙-不需要开启那么多功能和接口-只开启防火墙相对应的功能和接口相对来说比较稳定-不会太卡重启即可-优点稳定-高效-根据数据包里的信息过滤-解决兼容性问题-安全漏洞问题较小-成本降低根据用户群体需求提升性能-作为网络安全防护的主要设备-缺点功能没有软件级那么强大font-color00dddd常见的硬件防火墙font华为-思科-天融信-深信服-飞塔-浪潮-中新金盾绿盟科技-juniper-启明星辰-网康-netgear">硬件级（类似于原生架构）：独立硬件，嵌入式应用程序。（这个操作系统本身就是防火墙）。不需要开启那么多功能和接口。只开启防火墙相对应的功能和接口，相对来说比较稳定。不会太卡，重启即可。<br>
优点：<br>
稳定、高效。根据数据包里的信息过滤。解决兼容性问题。安全漏洞问题较小。成本降低，根据用户群体需求提升性能。作为网络安全防护的主要设备。<br>
缺点：<br>
功能没有软件级那么强大<br>
<font color="#00dddd">常见的硬件防火墙：</font><br>
华为	         思科	         天融信         	深信服         	飞塔         	浪潮	         中新金盾		<br>
绿盟科技	                           	Juniper	                           启明星辰	                           网康                           	NETGEAR</h2>
<p><font color="#660000" size=5>【2】按功能分类</font><br>
1）包过滤型防火墙<br>
抓取通过设备的数据包，对数据流层的内容进行过滤。能够检查数据包中的服务端口、IP（目标、源）地址、MAC（目标、源）地址等信息。【在现在的防火墙技术中作为基本功能应用】<br>
2）应用层防火墙<br>
数据包分析功能工作在应用层，可以针对应用层的很多软件进行监听和防护。对信息类的数据进行监控分析，对传输的文件类型进行监控<br>
3）包检测型防火墙<br>
抓取用户的访问请求，预判用户的下一步动作，并对动作进行监听【判断是否是入侵行为，DDos攻击等】<br>
4）网络行为管理防火墙<br>
【在应用层+检测型防火墙基础上增加了更多分析和统计，记录功能】上网行为监控，域名访问记录、软件访问记录、搜索记录、论坛消息记录、QQ微信等软件聊天信息记录、电子邮件等5）华为称为下一代防火墙【是一款可以全面应对“应用层威胁”的高性能防火墙】</p>
<h2 id="根据存放位置网络型主机防火墙">根据存放位置：<br>
网络型<br>
主机防火墙</h2>
<p><font color="#660000" size=5>【3】防火墙概念</font><br>
是指设置在不同网络与网络安全域之间的一系列部件的组合，也是不同安全域之间信息的唯一出口。通过检测、限制并更改跨越防火墙的数据流，尽可能的对外屏蔽网络内部信息、结构和运行状态，且有选择的接受外部网络访问。</p>
<p><font color="#660000" size=5>【4】Linux包过滤防火墙</font><br>
iptables：用户态，规则列表。为netfilter提供命令/规则的工具，由用户定义（位于/sbin/iptables）<br>
firewalld：用户态，规则列表。为netfilter提供命令/规则的工具，由用户定义【CentOS7默认的管理防火墙规则的工具】<br>
netfilter：内核态，内核模块。提供数据转发、丢弃等功能。执行规则。接受数据包、封装数据包、转发数据包、丢弃数据包。【系统内核对数据包的处理机制】<br>
iptables/netfilter的最大优点是它可以配置有状态的防火墙（使用户可以完全控制防火墙配置和信息包过滤。从而制定自己的规则，只允许您想要的网络流量进入系统）</p>
<p><font color="#dd0000" size=6><strong>iptables：</strong></font><br>
【5】iptables防火墙规则<br>
Iptables 是用来设置、维护和检查Linux内核的IP包过滤规则的。<br>
可以定义不同的表，每个表都包含几个内部的链，也能包含用户定义的链。每个链都是一个规则列表，对对应的包进行匹配：每条规则指定应当如何处理与之相匹配的包。这被称作'target'（目标），也可以跳向同一个表内的用户定义的链。<br>
<font color="#00dd00"><br>
钩子函数：4表5链<br>
规则：                             表代表数据包的处理区域        ；     链处理数据包的时机</font></p>
<p><font color="#660066">5链：利用五种钩子函数存放过滤规则，叫做规则链</font><br>
规则链：<br>
规则的作用： 在链内设置规则，由规则负责对数据包过滤和处理<br>
链的作用：容纳各种防火墙规则<br>
链的分类依据：处理数据包的不同时机<font color="#dd0000"><br>
默认包括5种规则链<br>
input：处理入站数据<br>
forward：处理转发的数据<br>
output：处理出站数据<br>
prerouting：路由之前检查（路由选择之前处理数据包，进行目标地址转换）<br>
postrouting：路由之后检查（路由选择之后处理数据包，进行源地址转换）。PAT                           prerouting：路由之前                 postrouting：路由之后</font></p>
<p><font color="#660066">4表：【规则链存放在表中，规则存放在规则链中】存放规则链的表叫做规则表  </font>                                raw：原始的，未经分析的     Mangle：压碎      Nat：地址转换    Filter：过滤，筛选<font color="#dd0000"><br>
raw表：确定是否对数据包进行状态跟踪。                                                    包括：prerouting、output链<br>
filter表：过滤表，决定是否放行数据包。                                                      包括：input、forward、output链<br>
nat表：地址转换表。                                                                                     包括：prerouting、output、postrouting链<br>
mangle表：为数据包做标记，数据包需要做什么。                                      包括：prerouting、input、forward、output、postrouting链</font><br>
拓展：<br>
security表：security是跟selinux相关的MAC模式的安全过滤。<br>
表的作用：容纳各种规则链</p>
<p><font color="#660000" size=5>【6】表和链的执行顺序</font><br>
6-1）iptables数据流顺序（规则表之间的顺序）<br>
raw→mangle→nat→filter</p>
<p>6-2）规则链之间的顺序<br>
】入站：prerouting→input<br>
（prerouting：路由之前检查（路由选择之前处理数据包，目标地址转换））<br>
外界的数据包到达防火墙后，首先被prerouting链处理（是否修改地址等），然后进行路由选择，如果数据包的目标地址是本机，那么内核将数据包传递给input进行处理，然后交给上层应用程序<br>
】出站：output→postrouting<br>
（postrouting：路由之后检查（路由选择之后处理数据包，源地址转换））<br>
防火墙本机向外部地址发送的数据包，首先内output处理，然后进行路由选择，再交给postrouting处理<br>
】转发：prerouting→forward→postrouting<br>
外部数据包到达防火墙后，首先被prerouting链处理，然后进行路由选择~如果数据包的目标地址是其他外部地址，则内核交给forward链进行处理，最后交给postrouting链处理</p>
<h2 id="规则链内的匹配顺序按顺序依次检查匹配即停止log策略例外若找不到相匹配的规则则按该链的默认策略处理">规则链内的匹配顺序<br>
按顺序依次检查，匹配即停止（LOG策略例外）<br>
若找不到相匹配的规则，则按该链的默认策略处理</h2>
<p><font color="#660000" size=5>【7】iptables命令语法</font><br>
<strong>1）语法格式</strong><br>
iptables  [-t 表名]  参数  [链名]  [条件表达式]  [-j 控制类型]</p>
<p><strong>2）[表名]：filter表   或   nat表（不加-t 表名选项，默认为filter表）</strong></p>
<p><strong>3）参数：</strong><br>
-A：添加一条规则，添加在链的尾部<br>
-I:插入一条规则，插入对应的链（在链的开头或指定序号插入一条规则）<br>
-C:将规则添加到用户定义链之前对其进行检查<br>
-D:删除指定链中某条规则<br>
-R:替换链上的某条规则<br>
-P:定义某个链的默认规则<br>
-N:自定义一个新的空链<br>
-X:删除一个自定义的空链<br>
-F：清空指定规则链，如果省略链，则可以实现删掉对应表的中所有链（常用）<br>
-Z:重置指定链中的所有规则计数器<br>
-E:重命名自定义的链，不改变链本身<br>
-L:显示指定表中的规则<br>
-n：以数字形式显示主机地址和端口号（-n -L 可合写为 -nL）<br>
-v：显示详细规则信息<br>
-vv：显示更详细信息<br>
-x：显示计数器的精确值<br>
--line-number：查看规则时，显示规则的序号</p>
<p><strong>4）[条件表达式]：需要分析的数据包头部信息对象</strong><br>
通用匹配<br>
协议类：-p  tcp/udp/icmp<br>
端口类：--dport  目标端口号	--sport  源端口号<br>
地址类：-s  源IP地址/子网掩码		-d    目标IP地址/子网掩码               （单独主机地址地址不用加子网掩码）<br>
接口类：-i   网卡接口名称        输入接口	例：-i   ens33<br>
-o  网卡接口名称        输出接口             例：-o  ens37<br>
特殊分类（隐含匹配）<br>
TCP标记匹配：--tcp-flags 检查范围 被设置的标记<br>
ICMP类型匹配：--icmp-type 类型ID            8请求    0回应    3不可达</p>
<p><strong>5）其他分流（显示匹配）</strong><br>
要求以“-m 扩展模块”的形式明确指出类型<br>
多端口匹配：<br>
-m  multiport   --sport    源端口列表（1024-2048）                       multi：多种，多数                range：一系列，范围          src：源对象        source：来源         dst：目标<br>
-m  multiport   --dport   目标端口列表（2000-3000）<br>
IP范围匹配<br>
-m  iprange  --src-range  IP范围（192.168.10.10-192.168.10.20）<br>
-m  iprange  --dst-range  IP范围（例如：192.168.10.100-192.168.10.200）<br>
MAC范围匹配<br>
-m mac  --mac-source  MAC地址</p>
<p>状态匹配<br>
-m state --state 连接状态<br>
状态：<br>
ESTABLISHED：指出该信息包属于已建立的连接，该连接一直用于发送和接收信息包并且完全有效。<br>
INVALID：指出该信息包与任何已知的流或连接都不相关联，它可能包含错误的数据或头。<br>
NEW：意味着该信息包已经或将启动新的连接，或者它与尚未用于发送和接收信息包的连接相关联。<br>
RELATED：表示该信息包正在启动新连接，以及它与已建立的连接相关联。</p>
<p>字符串匹配<br>
-m  string --string &quot;关键字&quot; --alog bm<br>
选项说明：<br>
-m string               //匹配字符串规则<br>
--string &quot;&quot;             //引号中添字符串<br>
--algo   bm           //字符串编码转换算法</p>
<p><strong>6）[控制类型]：</strong><br>
-j ACCEPT：允许通过                                                    accept：同意，接受             reject：拒收，拒绝接受                 algo：算法<br>
-j DROP：直接丢弃，不给出任何回应<br>
-j REJECT：拒绝通过，必要时会给出提示<br>
-j LOG：记录日志信息，然后传给下一条规则继续匹配</p>
<p>iptables  [-t 表名]  参数  [链名]  [条件]  [-j 控制类型]<font color="#dd0000"><br>
几个注意事项<br>
不指定表名时，默认指filter表<br>
不指定链名时，默认指表内的所有链<br>
除非设置链的默认策略，否则必须指定匹配条件<br>
参数、链名、控制类型使用大写字母，其余均为小写</font></p>
<p>iptables   -t  filter   -A  INPUT   -p   icmp  -s   192.168.1.1  -d  192.168.1.20  -j  DROP<br>
在链尾添加一条规则：对来源于192.168.1.1，目标地址为192.168.1.20的数据包在入站时进行丢弃</p>
<p><font color="#660000" size=5>【8】基本操作语句【防火墙关闭查看[stop firewalld]，更加明显】</font><br>
查看当前规则<br>
iptables -t filter -L<br>
清除所有规则<br>
iptables -F<br>
iptables -L<br>
修改指定链的默认规则<br>
iptables -t filter  -P INPUT DROP</p>
<p><font color="#660000" size=5>【9】案例（防火墙firewalld关闭即可）</font><br>
<strong>例1：拒绝本地主机和任何其他主机“互ping”</strong><br>
iptables   -t  filter   -A  INPUT   -p   icmp   -j  DROP                                                      //在filter表INPUT链的末尾添加icmp协议规则，动作为DROP<br>
<strong>例2：拒绝192.168.1.1  ping本地其他主机</strong><br>
iptables   -t  filter   -A  INPUT   -p   icmp  -s   192.168.1.1  -j  DROP<br>
<strong>例3：本地主机能ping其他主机，但其他主机不能ping本地主机</strong><br>
iptables   -t  filter   -A  INPUT   -p   icmp     --icmp-type   8     -j  DROP<br>
ping<br>
请求：request   8<br>
回应：reply  0（默认链的ICMP类型为0，所有本实验中不用设置OUTPUT输出链）<br>
不可达:3</p>
<p><strong>例4：允许本地主机能ping其他主机，除（某一个IP）外，不允许其他主机ping本地主机（基于上述实验基础上）</strong><br>
分析：希望某一个IP地址可以访问。我们可以允许INPUT链中，来自（某一IP），ICMP协议中类型8的数据包。但是第一条为拒绝了所有，所以我们需要将策略插入到“拒绝的策略”之前<br>
[root@localhost ~]# iptables -I INPUT 1 -s 192.168.2.11 -p icmp --icmp-type 8 -j ACCEPT<br>
[root@localhost ~]# iptables -L<br>
Chain INPUT (policy ACCEPT)                                            chain：锁链，一系链               ACCEPT：同意，许可               anywhere：任何地方           opt：选择，挑选       drop：丢弃<br>
target     prot opt source               destination<br>
ACCEPT     icmp --  192.168.2.11         anywhere             icmp echo-request<br>
DROP       icmp --  anywhere             anywhere             icmp echo-request</p>
<p>Chain FORWARD (policy ACCEPT)<br>
target     prot opt source               destination<br>
Chain OUTPUT (policy ACCEPT)<br>
target     prot opt source               destination</p>
<p><strong>例5：拒绝客户的192.168.2.1主机访问本地httpd服务</strong><br>
分析：客户端发来的数据包为输入，所以在INPUT链中配置。根据封装结构，收到的这个数据包源IP地址是192.168.2.1，目标端口号是80端口。<br>
[root@localhost ~]# iptables -A INPUT -s 192.168.2.1  -p tcp --dport 80 -j DROP<br>
[root@localhost ~]# iptables -L<br>
Chain INPUT (policy ACCEPT)<br>
target     prot opt source               destination<br>
DROP       tcp  --  192.168.2.1          anywhere             tcp dpt:http</p>
<p><strong>例6：我不想开放我的其他端口，但我要在我的电脑上启用http服务，并对外服务</strong><br>
案例分析:防火墙的规则匹配方式为首行配置制,也就是该当收到数据包后,进行规则表达式匹配。当第一行规则满足条件后,就不再往下进行匹配了，<br>
所以如果我们把包含范围比较大的规则写在前面,则范围小的规则将不再有机会匹配！！！<br>
如:我们在第一行写了一个拒绝所有客户端访问本地主机,在第二行以后再添加允许192.168.10.2访问本地主机,则无法匹配了。</p>
<p>总结：在设置规则时我们应该先制定匹配范围最小的规则再制定匹配范围大的规则<br>
操作如下：<br>
[root@localhost ~]# iptables -D INPUT 1                                                          从链中删除了第一行的规则<br>
[root@localhost ~]# iptables -A INPUT -p tcp --dport 80 -j ACCEPT<br>
[root@localhost ~]# iptables -A INPUT -p tcp -j DROP<br>
[root@localhost ~]# iptables -A INPUT -p udp -j DROP<br>
[root@localhost ~]# iptables -L<br>
Chain INPUT (policy ACCEPT)<br>
target     prot opt source               destination<br>
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http<br>
DROP       tcp  --  anywhere             anywhere<br>
DROP       udp  --  anywhere             anywhere</p>
<p><strong>例7：拒绝192.168.1.1访问文件服务</strong><br>
案例分析:在配置规则时有些服务是多端口的,我们要指定关键端口,或配置相关的所有端口,有些服务是在TCP协议和UDP协议中都有端口的,我们要指定到,才能有效的进行控制<br>
如以下操作中, samba服务本身有两个端口号,139和445,一个负责传输文件,一个负责连接验证。<br>
nfs服务在tcp和udp中的端口号都是2049.<br>
[root@localhost ~]# iptables -t filter -F<br>
[root@localhost ~]# iptables -t filter -L<br>
拒绝samba<br>
[root@localhost ~]# iptables -t filter -A INPUT -p tcp --dport 139 -s 192.168.1.1 -j DROP<br>
[root@localhost ~]# iptables -t filter -A INPUT -p tcp --dport 445 -s 192.168.1.1 -j DROP<br>
拒绝nfs<br>
[root@localhost ~]# iptables -t filter -A INPUT -p tcp --dport 2049 -s 192.168.1.1 -j DROP<br>
[root@localhost ~]# iptables -t filter -A INPUT -p udp --dport 2049 -s 192.168.1.1 -j DROP<br>
[root@localhost ~]# iptables -L</p>
<p><strong>例8：只允许192.168.2.1-192.168.2.10之间的主机访问httpd服务器192.168.2.2（无亲测）</strong><br>
[root@localhost ~]# iptables -t filter -A INPUT  -m iprange --src-range 192.168.2.1-192.168.2.10  -d 192.168.2.2 -p tcp --dport 80 -j ACCEPT<br>
[root@localhost ~]# iptables -L<br>
Chain INPUT (policy ACCEPT)<br>
target     prot opt source               destination<br>
ACCEPT     tcp  --  anywhere             www.baidu.com        source IP range 192.168.2.1-192.168.2.10 tcp dpt:http<br>
————————————————————————<br>
<font color="#dd0000" size=6>firewalld：动态防火墙</font><br>
firewalld预定义的网络区域：                                           总结：所有区域的通行规则是：允许任何数据发出，拒绝任何数据传入，除指定类型的数据流量【预定义的服务】。<br>
<font color="#006600">firewalld默认创建了9个安全区域。        分为两大类，第一类通行区域，默认限定允许通行什么类型的数据。第二类拒绝区域，什么数据都不允许通行的区域。<br>
Trusted：信任，相信            public：公共的        work：工作         internal：内部的，里面的           external：外部的，外部        dmz：非军事化区       block：阻碍，堵塞    </font><br>
trusted 信任区域：可接受所有的网络连接</p>
<p>public 公共区域：除非与传出流量相关或与ssh或dhcpv6-client预定义服务匹配，否则拒绝流量传入<br>
应用场景：在公共区域内不能相信网络内的其他计算机，不会对计算机造成危害。只能接受经过选择的连接！并且该区域是新添加网络接口的默认区域</p>
<p>work 工作区域<br>
除非与传出流量相关或ssh ipp-client dhcp6-client预定义服务匹配否则拒绝流量传入。<br>
应用场景：用于工作区 相信网络内的其他计算机不会危害计算机 仅接收经过选择的连接</p>
<p>home 家庭区域<br>
除非与传出流量相关 或ssh ipp-client mdns samba-clientdhcpv6-client 预定义服务匹配 否则拒绝流量传入 。<br>
应用场景：用于家庭网络 信任网络内的其他计算机不会危害计算机 仅接收经过选择的连接</p>
<p>internal 内部区域<br>
除非与传出流量相关 或ssh ipp-client mdns samba-client dhcpv6-client预定义服务匹配否则拒绝流量传入<br>
应用场景：用于内部网络 信任网络内的其他计算机不会危害计算机 仅接收经过选择的连接</p>
<p>external 外部区域<br>
除非与传出流量相关 或与ssh预定义服务匹配，否则拒绝流量传入。<br>
应用场景：通过次区域转发的ipv4传出流量将进行地址伪装 可用于为路由器启用了伪装功能的外部网络</p>
<p>dmz 隔离区域也称为非军事区域<br>
除非与传出的流量相关 或与ssh预定义服务匹配，否则拒绝流量传入</p>
<p>block 限制区域<br>
除非与传出流量相关 ,否则拒绝所有传入流量drop。并且不产生包含ICMP（internet control message protocol 互联网控制报文协议）的错误响应</p>
<p>drop：丢弃区域，许流量传出，拒绝所有流量传入，并且不产生ICMP错误响应<br>
不同的区域之间的差异是其“对待数据包”的默认行为不同，firewalld的默认区域为public</p>
<p><font color="#dd00dd" face="楷体" size=5>firewalld特点：</font><br>
1.増加了网络区域安全设置,网络区域中可以放入接口,不同的区域设置了不同的安全级别。<br>
2.支持ipv4和ipv6两种策略表以及以太网桥<br>
3.支持服务或应用程序直接添加规则接口<br>
4.支持两种配置模式:运行配置,永久配置</p>
<p><font color="#660000">firewalld的配置文件以xml格式为主（主配置文件firewalld.conf例外），他们有两个存储位</font><br>
1、/etc/firewalld/<br>
2、/usr/lib/firewalld/<br>
使用时的规则是这样的：当需要一个文件时firewalld会首先到第一个目录中去查找，如果可以找到，那么就直接使用，否则会继续到第二个目录中查找。</p>
<p>firewalld的这种配置文件结构的主要作用是这样的：在第二个目录中存放的是firewalld给提供的通用配置文件，如果我们想修改配置， 那么可以copy一份到第一个目录中，然后再进行修改。这么做有两个好处：首先我们日后可以非常清晰地看到都有哪些文件是我们自己创建或者修改过的，其 次，如果想恢复firewalld给提供的默认配置，只需要将自己在第一个目录中的配置文件删除即可，非常简单，而不需要像其他很多软件那样在修改之前还 得先备份一下，而且时间长了还有可能忘掉之前备份的是什么版本。（主要是services目录下的区域文件）</p>
<h1 id="firewalld相关文件1防火墙内置支持的服务路径usrlibfirewalldservices-格式服务名html2默认区域配置文件etcfirewalldzones-默认为public3默认防火墙主配置文件etcfirewalldfirewalldconf4预定义网络区域存储位置usrlibfirewalldzones">firewalld相关文件：<br>
（1）防火墙内置支持的服务路径:/usr/lib/firewalld/services/          格式：服务名.html<br>
（2）默认区域配置文件：/etc/firewalld/zones/                                默认为public<br>
（3）默认防火墙主配置文件：/etc/firewalld/firewalld.conf<br>
（4）预定义网络区域存储位置：/usr/lib/firewalld/zones/</h1>
<p>————————————————————————————————————————————————————<br>
<font color="#dd00dd" face="楷体" size=5>firewalld运行规则：</font><br>
<strong>1、数据包的处理方式</strong><br>
iptables防火墙:<font color="#dd0000" face="微软黑体"><br>
输入数据: PREROUTING---INPUT<br>
输出数据: OUTPUT--POSTROUTING<br>
转发数据: PREROUTING-FORWARD-POSTROUTIN</font></p>
<p>firewalld防火墙:<br>
firewalld的数据机制为“处理收到的数据包”<font color="#dd0000" face="黑体"><br>
1.若接口加入到指定的安全区域，数据包中的源地址首先匹配特定区域，如果满足规则,则执行数据包处理动作。<br>
2.若接口未加入到指定的安全区域。数据包中的源地址则无法匹配指定区域规则，则使用接口的本地区域规则进行数据包处理动作。<br>
3.数据包的源地址无法匹配接口规则时,则使用默认区域规则处理数据包</font></p>
<p><strong>2、firewalld规则配置</strong><br>
firewalld图形化界面：firewall-config<br>
命令行界面：firewall-cmd 选项 规则语句<br>
————————————————————————————————————————————————————<br>
<font color="#dd0000" size=6>firewalld配置命令</font><br>
<font color="#0000dd" size=4>【选项】</font><br>
<strong>1-1、查看类选项</strong><br>
查看所有区域名称<br>
firewall-cmd  --get-zones<br>
查看支持的服务<br>
firewall-cmd --get-services<br>
查看支持的ICMP协议类型<br>
firewall-cmd --get-icmptypes<br>
查看默认区域<br>
firewall-cmd --get-default-zone<br>
查看活动区域<br>
firewall-cmd --get-active-zones<br>
查看指定区域信息<br>
firewall-cmd --zone=区域名 --list-all （省去--zone默认区域为public）<br>
firewall-cmd --zone=home --list-all<br>
显示的信息说明：<br>
home (active)			#区域名称及状态(active活动状态)<br>
target: default		#匹配默认规则<br>
icmp-block-inversion: no	#未启用ICMP消息过滤<br>
interfaces: ens33		#当前连接网络接口<br>
sources: 			#源地址规则<br>
services: dhcpv6-client mdns samba-client ssh    #允许访问服务<br>
ports: 			#允许访问的端口<br>
protocols: 			#允许访问的协议<br>
masquerade: no		#地址伪装未启用<br>
forward-ports: 		#端口转换<br>
sourceports: 			#源端口号<br>
icmp-blocks: 			#icmp消息过滤类型<br>
rich rules: 			#富语言<br>
查看指定端口绑定的区域<br>
firewall-cmd --get-zone-of-interface=端口名称（例：ens33）<br>
查看所有区域信息<br>
firewall-cmd --list-all-zones</p>
<p><strong>1-2、区域配置类选项</strong><br>
--zone=区域名                                  指定配置区域<br>
--add-interface=网络接口名           添加接口<br>
<font face="楷体" color="#006666">1-2.1）指定默认区域</font><br>
firewall-cmd --set-default-zone=区域名（例：external）<br>
<font face="楷体" color="#006666">1-2.2）在指定的区域添加接口</font><br>
firewall-cmd --zone=区域名 --add-interface=端口名称                  一个网卡接口只能加入一个安全区域，以最后加入的区域为准。而一个安全区域能够添加多个网卡接口。<br>
例：<br>
firewall-cmd --zone=internal --add-interface=ens37<br>
<font face="楷体" color="#006666">1-2.3）从指定区域删除接口（删除的接口会自动添加到默认区域）</font><br>
firewall-cmd --zone=区域名 --remove-interface=端口名称<br>
例：<br>
firewall-cmd --zone=internal --remove-interface=ens37<br>
<font face="楷体" color="#006666">1-2.4）更改接口的绑定区域</font><br>
firewall-cmd --zone=区域名 --change-interface=端口名称<br>
例：<br>
firewall-cmd --zone=internal --change-interface=ens37</p>
<p><strong>1-2.5）在区域中添加服务</strong><br>
firewall-cmd --zone=区域名  --add-service=服务名                   //可以让区域接收服务访问请求。      注意：每条语句只能添加一个服务<br>
例：<br>
firewall-cmd --zone=external --add-service=https<br>
从区域中删除服务<br>
firewall-cmd --zone=区域名 --remove-service=服务名<br>
例：<br>
firewall-cmd --zone=external --remove-service=https<br>
<strong>1-2.6）在区域中添加端口号</strong><br>
firewall-cmd --zone=区域名 --add-port=端口号/协议类型       //添加TCP或UDP协议中的端口号！！！为指定区域设置允许访问的某个/某段端口号（包括协议名）<br>
例：<br>
firewall-cmd --zone=external --add-port=12345/tcp                                     端口号可以是个范围：--add-port=100-200/tcp<br>
删除指定区域已设置的允许访问的端口号（包括协议名）：--remove-port<br>
<strong>1-2.7）添加拒绝的ICMP数据包类型</strong><br>
echo-request：icmp请求<br>
echo-reply ：icmp应答<br>
firewall-cmd --zone=区域名 --add-icmp-block=echo-request<br>
例：<br>
firewall-cmd --zone=external --add-icmp-block=echo-request</p>
<h2 id="移除拒绝的icmp数据包请求删除指定区域已设置的拒绝访问的某项icmp类型省略-zonezone时表示对默认区域操作-zonezone-remove-icmp-blockicmptypeicmptypefirewall-cmd-zonedmz-remove-icmp-blockecho-request">移除拒绝的ICMP数据包请求<br>
删除指定区域已设置的拒绝访问的某项ICMP类型，省略--zone=<zone>时表示对默认区域操作<br>
[--zone=<zone>] --remove-icmp-block=&lt;icmptype<icmptype>&gt;<br>
firewall-cmd --zone=dmz --remove-icmp-block=echo-request</h2>
<p>1-2.8）查看指定区域内允许访问的服务<br>
firewall-cmd --zone=区域名 --list-services<br>
例：<br>
firewall-cmd --zone=external --list-services<br>
1-2.9）查看指定区域内允许访问的端口列表<br>
firewall-cmd --zone=区域名 --list-ports<br>
例：<br>
firewall-cmd --zone=external --list-ports</p>
<h2 id="1-210查看拒绝的icmp数据包类型firewall-cmd-zone区域名-list-icmp-blocks例firewall-cmd-zoneexternal-list-icmp-blocks">1-2.10）查看拒绝的ICMP数据包类型<br>
firewall-cmd --zone=区域名 --list-icmp-blocks<br>
例：<br>
firewall-cmd --zone=external --list-icmp-blocks</h2>
<p><font color="#dd0000" size=6 face="楷体">重点：配置模式</font><br>
2-1）重新加载防火墙，激活永久配置（简单理解：只有在添加防火墙规则时，才需要重新加载防火墙）<br>
firewall-cmd --reload            读取firewalld的配置信息，加载配置规则。相当于重启服务，重新读取配置。<br>
2-2）永久配置<br>
--permanent<br>
2-3）把运行配置保存到永久配置<br>
--runtime-to-permanent                                 permanent：永久的             runtime：运行时间                     reload：重新加载<br>
注意：在输入规则时，不写--permanent选项，规则是临时生效的，重新启动服务，重启系统，重新加载配置都会丢失以添加的规则。一般使用临时规则的方式进行测试，功能实现后，再添加--permanent选项设置为永久生效。😎😎😎</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是repo文件？ ]]></title>
        <id>https://www.zhz666.cf/post/shi-me-shi-repo-wen-jian/</id>
        <link href="https://www.zhz666.cf/post/shi-me-shi-repo-wen-jian/">
        </link>
        <updated>2020-12-13T04:35:52.000Z</updated>
        <content type="html"><![CDATA[<p>repo文件是Fedora中yum源（软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用！<br>
YUM的工作原理并不复杂，每一个 RPM软件的头（header）里面都会纪录该软件的依赖关系，那么如果可以将该头的内容纪录下来并且进行分析，可以知道每个软件在安装之前需要额外安装 哪些基础软件。也就是说，在服务器上面先以分析工具将所有的RPM档案进行分析，然后将该分析纪录下来，只要在进行安装或升级时先查询该纪录的文件，就可 以知道所有相关联的软件。所以YUM的基本工作流程如下：</p>
<h2 id="服务器端在服务器上面存放了所有的rpm软件包然后以相关的功能去分析每个rpm文件的依赖性关系将这些数据记录成文件存放在服务器的某特定目录内-客户端如果需要安装某个软件时先下载服务器上面记录的依赖性关系文件可通过www或ftp方式通过对服务器端下载的纪录数据进行分析然后取得所有相关的软件一次全部下载下来进行安装">服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。<br>
客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。</h2>
<p>rpm    --nodeps：安装时忽略依赖关系。<br>
缺少依赖关系，导致部分软件不能正常使用<br>
yum：由redhat推出的服务，rpm包管理器，对依赖数据包进行更新安装工具</p>
<p>yum主配置目录：/etc/yum.repos.d/<br>
yum主配置文件:  /etc/yum.conf<br>
YUM主配文件:/etc/yum.conf</p>
<h2 id="font-colordd0000yum重要的目录和文件fontpackages存储rpm包repodata记录软件依赖关系cd-repodatarepomdxml-xml列表-查找软件依赖关系"><font color="#dd0000">yum重要的目录和文件：</font><br>
Packages	存储rpm包<br>
repodata	记录软件依赖关系<br>
cd repodata→repomd.xml  （xml列表 查找软件依赖关系）</h2>
<p>[root@localhost ~]# ll /etc/yum.repos.d/<br>
总用量 28<br>
-rw-r--r--. 1 root root 1664 11月 30 2016 CentOS-Base.repo                                           //联网后基础的源<br>
-rw-r--r--. 1 root root 1309 11月 30 2016 CentOS-CR.repo<br>
-rw-r--r--. 1 root root  649 11月 30 2016 CentOS-Debuginfo.repo                                    //和内核相关的更新和软件安装<br>
-rw-r--r--. 1 root root  314 11月 30 2016 CentOS-fasttrack.repo<br>
-rw-r--r--. 1 root root  630 11月 30 2016 CentOS-Media.repo                                               //使用光盘挂载后调用的文件<br>
-rw-r--r--. 1 root root 1331 11月 30 2016 CentOS-Sources.repo<br>
-rw-r--r--. 1 root root 2893 11月 30 2016 CentOS-Vault.repo                                                   //最近新版本的加入的（老版本的yum源配置）<br>
工作原理！<br>
yum通过读取yum源配置文件，确认软件包源文件路径，读取路径中，两个目录中的文件信息。<br>
1.repodata目录：软件包依赖环境参照表。目录中有*.xml文件，文件中记录了软件的依赖环境。<br>
2.Packages目录：统计完需要安装的依赖关系后，从此目录中读取相关软件包。<br>
3.将软件包复制到缓存后，进行解压安装。</p>
<h1 id="font-color00dddd-size5第一部分font"><font color="#00dddd" size=5>第一部分：</font></h1>
<p>vim  /etc/yum.conf<br>
[main]<br>
cachedir=/var/cache/yum/$ basearch/$ releasever          #cachedir：yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum/$ basearch/$ releasever。</p>
<p><font color="#dd0000">keepcache=1<br>
#keepcache：是否保留缓存内容，0：表示安装后删除软件包，1表示安装后保留软件包</font></p>
<p>debuglevel=2<br>
#debuglevel：除错级别，0──10,默认是2 貌似只记录安装和删除记录<br>
logfile=/var/log/yum.log<br>
pkgpolicy=newest<br>
#pkgpolicy： 包的策略。一共有两个选项，newest和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository中同时存 在，yum应该安装哪一个，如果是newest，则yum会安装最新的那个版本。如果是last，则yum会将服务器id以字母表排序，并选择最后的那个 服务器上的软件安装。一般都是选newest。</p>
<p>distroverpkg=centos-release<br>
#指定一个软件包，yum会根据这个包判断你的发行版本，默认是redhat-release，也可以是安装的任何针对自己发行版的rpm包。</p>
<p>tolerant=1<br>
#tolerent，也有1和0两个选项，表示yum是否容忍命令行发生与软件包有关的错误，比如你要安装1,2,3三个包，而其中3此前已经安装了，如果你设为1,则yum不会出现错误信息。默认是0。<br>
exactarch=1<br>
#exactarch，有两个选项1和0,代表是否只升级和你安装软件包cpu体系一致的包，如果设为1，则如你安装了一个i386的rpm，则yum不会用1686的包来升级。</p>
<p>retries=20<br>
#retries，网络连接发生错误后的重试次数，如果设为0，则会无限重试。<br>
obsoletes=1<br>
<font color="#dd0000">gpgcheck=1<br>
#gpgchkeck= 有1和0两个选择，分别代表是否是否进行gpg校验，如果没有这一项，默认是检查的。 </font><br>
reposdir=/etc/yy.rm #默认是 /etc/yum.repos.d/ 低下的 xx.repo后缀文件<br>
#默认都会被include 进来 也就是说 /etc/yum.repos.d/xx.repo 无论配置文件有多少个 每个里面有多少个[name] 最后其实都被整合到 一个里面看就是了 重复的[name]后面的覆盖前面的<br>
exclude=xxx<br>
#exclude 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。<br>
keepcache=[1 or 0]<br>
#　　设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为 keepcache=0 不保存</p>
<p>reposdir=[包含 .repo 文件的目录的绝对路径]<br>
#　　该选项用户指定 .repo 文件的绝对路径。.repo 文件包含软件仓库的信息 (作用与 /etc/yum.conf 文件中的 [repository] 片段相同)。</p>
<h1 id="font-color00dddd-size5第二部分font"><font color="#00dddd" size=5>第二部分：</font></h1>
<p>vi /etc/yum.repo.d/xx.repo<br>
这个字段其实也可以在yum.conf里面直接配置</p>
<p>[serverid]<br>
#其中serverid是用于区别各个不同的repository，必须有一个独一无二的名称。 重复了 前面覆盖后面--还是反过来呢？？？用enabled 测试是后面覆盖前面<br>
name=Some name for this server<br>
#name，是对repository的描述，支持像$releasever $basearch这样的变量; name=Fedora Core $releasever - $basearch - Released Updates</p>
<p><font color="#dd0000">baseurl=url://path/to/repository/<br>
#baseurl是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。它的格式是： </font><br>
baseurl=url://server1/path/to/repository/<br>
url://server2/path/to/repository/<br>
url://server3/path/to/repository/<br>
#其中url支持的协议有 http:// ftp:// file://三种。baseurl后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl只能有一个，也就是说不能像如下格式：<br>
<font color="#00dd00">baseurl=url://server1/path/to/repository/<br>
baseurl=url://server2/path/to/repository/<br>
baseurl=url://server3/path/to/repository/    </font><br>
其中url指向的目录必须是这个repository header目录的上一级，它也支持$releasever $basearch这样的变量。</p>
<p>#mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 11: releasever&amp;̲arch='>releasever&amp;arch=</span>basearch<br>
#上面的这一行是指定一个镜像服务器的地址列表，通常是开启的，本例中加了注释符号禁用了，我们可以试试，将$ releasever和$ basearch替换成自己对应的版本和架构，例如10和i386，在浏览器中打开，我们就能看到一长串镜可用的镜像服务器地址列表。</p>
<p><font color="#dd00dd">url之后可以加上多个选项，如gpgcheck、exclude、failovermethod等，比如：</font><br>
gpgcheck=1<br>
exclude=gaim<br>
#其中gpgcheck，exclude的含义和[main]部分相同，但只对此服务器起作用，<br>
failovermethod=priority<br>
#failovermethode 有两个选项roundrobin和priority，意思分别是有多个url可供选择时，yum选择的次序，roundrobin是随机选择，如果连接失 败则使用下一个，依次循环，priority则根据url的次序从第一个开始。如果不指明，默认是roundrobin。</p>
<p>enabled=[1 or 0]<br>
#当某个软件仓库被配置成 enabled=0 时，yum 在安装或升级软件包时不会将该仓库做为软件包提供源。使用这个选项，可以启用或禁用软件仓库。<br>
#通过 yum 的 --enablerepo=[repo_name] 和 --disablerepo=[repo_name] 选项，或者通过 PackageKit 的&quot;添加/删除软件&quot;工具，也能够方便地启用和禁用指定的软件仓库</p>
<p><font face="楷体" size=5><font color="#dd00dd">几个变量 </font></font><br>
$ releasever，发行版的版本，从[main]部分的distroverpkg获取，如果没有，则根据redhat-release包进行判断。<br>
$ arch，cpu体系，如i686,athlon等<br>
$basearch，cpu的基本体系组，如i686和athlon同属i386，alpha和alphaev6同属alpha。<br>
对yum.conf设定完成，我们就可以好好体验yum带来的方便了。</p>
<p>还有一件事没有做。那就是导入每个reposity的GPG key，前面说过，yum可以使用gpg对包进行校验，确保下载包的完整性，所以我们先要到各个repository站点找到gpg key，一般都会放在首页的醒目位置，一些名字诸如 RPM-GPG-KEY.txt之类的纯文本文件，把它们下载，然后用rpm --import xxx.txt命令将它们导入，最好把发行版自带GPG-KEY也导入。<br>
rpm --import /usr/share/doc/redhat-release-*/RPM-GPG-KEY 官方软件升级用的上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Yum库的搭建]]></title>
        <id>https://www.zhz666.cf/post/yum-ku-de-da-jian/</id>
        <link href="https://www.zhz666.cf/post/yum-ku-de-da-jian/">
        </link>
        <updated>2020-12-13T03:34:25.000Z</updated>
        <summary type="html"><![CDATA[<p><font color="#dd0000" size=5.5>（一）yum介绍</font><br>
<a href="https://baike.baidu.com/item/yum/2835771?fr=aladdin"><font color="#00dddd">yum库参考</font></a><br>
Yum(全称为 Yellow dogUpdater, Modified)是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
]]></summary>
        <content type="html"><![CDATA[<p><font color="#dd0000" size=5.5>（一）yum介绍</font><br>
<a href="https://baike.baidu.com/item/yum/2835771?fr=aladdin"><font color="#00dddd">yum库参考</font></a><br>
Yum(全称为 Yellow dogUpdater, Modified)是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<!-- more -->
<p><font color="#dd0000" size=5>（二）yum源实验</font><br>
使用YUM机制来更新系统和软件，需要有一个包含各种rpm安装包文件及其依赖的软件仓库（repository），提供软件仓库的服务器也称为“源”服务器。<br>
在客户机中只要正确指定软件仓库的地址等信息，就可以通过对应的“源”服务器来安装或更新软件了。<br>
1、yum<br>
使用rpm安装的软件有一个很大的弊端，在更新软件时，对依赖关系的版本号要求比较严格。yum可以帮助用户通过列表(xml)查询软件安装时所需的依赖关系，并且通过预定义的yum源下载和安装依赖关系。<br>
2、常用的yum源</p>
<p>1.本地源：在单服务器运行时常用的方式，将rpm软件包保存在本地目录中，安装软件时从本地读取文件，速度快，但更新维护比较繁琐。       将系统光盘或系统镜像文件挂载到指定目录，配置yum源。</p>
<p>2.ftp源：在公司的机房中，局域网中使用，将rpm软件包保存在ftp服务器的站点目录下，客户端配置ftp源，安装软件时可以通过ftp下载数据。ftp服务的弊端，访问并发量少，当访问用户比较多时，下载速度比较慢。</p>
<p>3.http源：使用web服务中,http协议的文件传输功能，通过广域网下载rpm软件包。便于推广，控制下载流量，并发连接数高。</p>
<p>3、更新yum仓库<br>
将新版本的rpm软件包复制到yum仓库目录中，相关的依赖关系软件包也复制到yum仓库目录中，更新xml列表文件。<br>
xml列表文件有两种更新方式：（1）手动更新（2）复制软件开发者制作的xml列表。</p>
<p><font size="4.5">【1】</font><br>
本地源：在服务器本地目录中存储rpm包<br>
优点：安装速度快<br>
缺点：只能本服务器自己使用<br>
[local]<br>
name=local<br>
baseurl=file://[目录]<br>
enabled=1                   #启用yum软件仓库<br>
gpgcheck=0                #取消gpg校验，一种密钥方式签名（默认检查）</p>
<p>例：<br>
rm -rf /etc/yum.repos.d/*<br>
vim /etc/yum.repos.d/yum.repo<br>
[yum]<br>
baseurl=file:///media/dvd<br>
enabled=1<br>
gpgcheck=0</p>
<p>mount /dev/cdrom /media/dvd（自己创建dvd目录）<br>
yum -y install httpd</p>
<p><font size="4.5">【2】</font><br>
FTP源：适用于局域网中，构建一台ftp服务器，将rpm包存储在FTP上，所有客户端的yum源指向FTP服务器<br>
优点：更新软件包时只需要更新FTP上的rpm包<br>
缺点：用户负载量低，不适用于广域网中大量的用户范围<br>
应用场景：<br>
适用于公司内部网络环境，和机房内部环境调用。不适用于广域网的原因：<br>
1.ftp用户身份验证的问题。<br>
2.ftp上下行工作机制导致传输效率比较低。<br>
3.ftp访问并发量较低。<br>
[ftp]<br>
name=ftp<br>
baseurl=ftp://ftp服务器IP地址/[目录]<br>
gpgcheck=0<br>
enabled=1</p>
<p>例：<br>
1、安装ftp服务器<br>
yum -y install vsftpd<br>
2、在FTP根目录中创建centos7的子目录<br>
默认目录/var/ftp<br>
mkdir /var/ftp/centos7                                                                     #默认匿名用户访问的“宿主根目录”为/var/ftp/目录~<br>
3、复制光盘中Packages和repodata目录到ftp根目录中（或者直接挂载到那个目录下）<br>
cp -r /media/dvd/Packages/ /var/ftp/centos7/<br>
cp -r /media/dvd/repodata/ /var/ftp/centos7/</p>
<p>systemctl restart vsftpd<br>
systemctl stop firewalld<br>
setenforce 0<br>
4、客户端配置<br>
rm -rf /etc/yum.repos.d/*<br>
[ftp]<br>
name=ftp<br>
baseurl=ftp://192.168.1.1/centos7<br>
gpgcheck=0<br>
enabled=1<br>
5、客户端测试<br>
yum -y install vsftpd<br>
yum -y install httpd<br>
yum -y remove httpd</p>
<p><font size="4.5">【3】</font><br>
HTTP源：适用于广域网，使用http服务器构建yum源。最多的一种yum仓库环境，传输速度相对比较稳定。<br>
优点：用户承载量大<br>
缺点：下载速度较慢<br>
[http]<br>
name=httpd<br>
baseurl=http://http服务器IP地址/[目录]<br>
gpgcheck=0<br>
enabled=1</p>
<p>例：<br>
1、安装httpd服务器<br>
yum -y install httpd                                                                    （注意：不能使用rpm -ivh的方式安装httpd）<br>
2、在站点根目录中创建centos7的子目录<br>
默认网页根目录/var/www/html<br>
mkdir /var/www/html/centos7<br>
3、复制光盘中Packages和repodata目录到ftp根目录中            （同理，也可以直接挂载到你创建的centos7目录）<br>
cp -r /media/dvd/Packages/ /var/www/html/centos7/       #这种方法太慢了，不如直接挂载！！！<br>
cp -r /media/dvd/repodata/ /var/www/html/centos7/</p>
<p>4.[root@localhost ~]# vim /etc/httpd/conf/httpd.conf（可省）<br>
修改：<br>
ServerName 192.168.10.1:80</p>
<p>systemctl restart httpd<br>
systemctl stop firewalld<br>
setenforce 0<br>
4、客户端配置<br>
rm -rf /etc/yum.repos.d/*<br>
[http]<br>
name=httpd<br>
baseurl=http://192.168.6.20/centos7<br>
gpgcheck=0<br>
enabled=1<br>
5、客户端测试<br>
yum -y install dhcp</p>
<p><font size="4.5">【4】CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。     【都需要虚拟机连网！！】</font><br>
<font color="#00dd00" size=5><font face="楷体">阿里源：</font></font><br>
[qwer]                                   #这个是自定义yum仓库，其实根本就不需要自定义！      因为你（下载的“源”文件会将“本地源”给覆盖掉，就可以使用了~）<br>
baseurl=https://mirrors.aliyun.com/repo/Centos-7.repo         #如果后续出错，就将这个文件下载到本地进行yum -y install makecache<br>
enable=1<br>
gpgcheck=0                           --可省了</p>
<p>Linux客户端配置方法：</p>
<ol>
<li>备份你的原镜像文件，以免出错后可以恢复<br>
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br>
2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/<br>
CentOS 7：<br>
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo<br>
或者<br>
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</li>
<li>清楚原有yum缓存   yum clean all，并运行 yum makecache 生成缓存        【可以通过yum repolist命令查看配置好的yum源是否正常】</li>
<li>其他<br>
非阿里云ECS用户会出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' 信息，不影响使用。用户也可自行修改相关配置: eg:</li>
</ol>
<p>sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo<br>
[5] 更新系统(时间比较久,主要看个人网速)  yum -y update<br>
[6] 安装vim编辑器  yum -y install vim*</p>
<p><font color="#00dd00" size=5><font face="楷体">华为源：</font></font><br>
1、备份配置文件：<br>
cp -a /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak<br>
2、两种方案，请大家自行选取。<br>
<strong>方案一：</strong><br>
下载新的CentOS-Base.repo文件到/etc/yum.repos.d/目录下，选择CentOS版本：<br>
CentOS 7<br>
执行如下命令：<br>
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.huaweicloud.com/repository/conf/CentOS-7-anon.repo</p>
<h2 id="方案二修改centos-baserepo文件取消baseurl开头的行的注释并增加mirrorlist开头的行的注释-将文件中的httpmirrorcentosorg替换成httpsmirrorshuaweicloudcom可以参考如下命令sed-i-sbaseurlbaseurlg-etcyumreposdcentos-basereposed-i-smirrorlisthttpmirrorlisthttpg-etcyumreposdcentos-basereposed-i-shttpmirrorcentosorghttpsmirrorshuaweicloudcomg-etcyumreposdcentos-baserepo3-执行yum-clean-all清除原有yum缓存-4-执行yum-makecache刷新缓存或者yum-repolist-all查看所有配置可以使用的文件会自动刷新缓存"><strong>方案二：</strong><br>
修改CentOS-Base.repo文件，取消baseurl开头的行的注释，并增加mirrorlist开头的行的注释。将文件中的http://mirror.centos.org替换成https://mirrors.huaweicloud.com，可以参考如下命令：<br>
sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo<br>
sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo<br>
sed -i &quot;s@http://mirror.centos.org@https://mirrors.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo<br>
3、执行yum clean all清除原有yum缓存。<br>
4、执行yum makecache（刷新缓存）或者yum repolist all（查看所有配置可以使用的文件，会自动刷新缓存）。</h2>
<p><font color="#0000dd" size=6>yum命令：</font><br>
增加“-y”选项，自动确认yum操作</p>
<p>yum -y install 软件名			//安装软件（常用）<br>
yum -y remove 软件名		//删除软件<br>
（只是删除本软件，不会删除依赖关系）	<br>
yum -y update			//更新软件<br>
yum info 软件名			//查看软件信息<br>
yum  list				//查看yum可用的软件列表<br>
yum -y groupinstall 软件组		//安装软件组<br>
例：<br>
yum -y groupinstall &quot;KDE&quot;</p>
<p>yum -y repolist			//查看可用yum源列表<br>
yum -y grouplist			//查看可用软件包组列表<br>
yum -y groupupdate 软件组		//更新软件组<br>
yum -y groupremove 软件组		//移除软件组<br>
（只是删除本软件，不会删除依赖关系）	<br>
yum -y clean all                                                 //清除yum缓存列表（常用）                                  clean：去除                search：搜索，查找</p>
<p>yum -y  search   命令字		//查看某命令属于哪个软件包<br>
例：<br>
yum -y search finger<br>
yum -y search rpm<br>
yum -y search yum</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shell脚本的“判断语句”]]></title>
        <id>https://www.zhz666.cf/post/shell-jiao-ben-de-pan-duan-yu-ju/</id>
        <link href="https://www.zhz666.cf/post/shell-jiao-ben-de-pan-duan-yu-ju/">
        </link>
        <updated>2020-12-02T14:00:30.000Z</updated>
        <content type="html"><![CDATA[<p>【1】、条件测试</p>
<p>是判断语句最基础的算法，通过固定的格式进行字符串或数值的比较。<br>
语句格式中，【在中括号的两端加空格，测试语句不会直接生成结果】，满足条件的会标记为0，不满足条件的标记为其他值。</p>
<p>格式1：test  条件表达式<br>
格式2：[  条件表达式  ]             #两个空格都不能少</p>
<p>【2】、文件测试</p>
<p>通过条件表达式，测试指定的文件或目录是否存在或其属性。</p>
<p>条件判断<br>
判断的方式两种<br>
1、test<br>
2、if</p>
<p>test：文件测试<br>
格式1：test 表达式<br>
格式2：[   表达式    ]            #括号前后有空格</p>
<p>-d：是否是目录<br>
-f：是否是文件<br>
-r：是否具有读权限<br>
-w：是否具有写入权限<br>
-x：是否具有执行权限          Exist：存在，生存            excute：执行，实施<br>
-e：测试文件或目录是否存在<br>
-s：是否是套接字<br>
-c：是否是字符集设备<br>
-b：是否是是块设备<br>
$?   存储上一次命令执行后的状态，执行成功为0 ,执行失败或报错为其他数值</p>
<p>[root@lala ~]# test -d aaa<br>
[root@lala ~]# echo $?<br>
1                                            --返回1表示执行出错<br>
[root@lala ~]# mkdir aaa<br>
[root@lala ~]# test -d aaa<br>
[root@lala ~]# echo $?<br>
0</p>
<p>[root@lala ~]# [ -d /media/dvd  ]<br>
[root@lala ~]# echo $?<br>
0<br>
[root@lala ~]# [ -d /media/dvd/server  ]<br>
[root@lala ~]# echo $?<br>
1</p>
<p>[root@lala ~]# [ -d /media ] &amp;&amp; echo &quot;yes&quot;<br>
yes<br>
[root@lala ~]# [ -d /media/dvd ] &amp;&amp; echo &quot;yes&quot;             &amp;&amp;（逻辑与，而且的意思）<br>
因为没有/media/dvd目录，所以不输出任何结果<br>
[root@lala ~]#  [ -d /media/dvd ] &amp;&amp; echo &quot;yes&quot; || echo no     || （逻辑或，“或者”的意思）<br>
no<br>
[root@lala ~]# [ -f aa.txt ] &amp;&amp; echo &quot;yes&quot;<br>
[root@lala ~]# touch aa.txt<br>
[root@lala ~]# [ -f aa.txt ] &amp;&amp; echo &quot;yes&quot;<br>
yes</p>
<p>检查看aa.txt文件的权限                                   【友情提示：不要去用大管root用户测试权限】<br>
[root@lala ~]# ls -l aa.txt<br>
-rw-r--r--. 1 root root 0 3月   2 15:53 aa.txt<br>
[root@lala ~]# [ -r aa.txt ] &amp;&amp; echo &quot;yes&quot;    （读权限）<br>
yes<br>
[root@lala ~]# [ -w aa.txt ] &amp;&amp; echo &quot;yes&quot;   （写权限）<br>
yes<br>
[root@lala ~]# [ -x aa.txt ] &amp;&amp; echo &quot;yes&quot;   （执行权限）<br>
因为没有执行权限，所以不输出任何内容<br>
[haha@localhost huaizhe]$ [ -x aa.txt ] &amp;&amp; echo &quot;yes&quot;  || echo 你没有权限<br>
你没有权限</p>
<p>[root@lala ~]# [ -e aa.txt ] &amp;&amp; echo &quot;yes&quot;    （是否存在）<br>
yes<br>
[root@lala ~]# [ -e a.txt ] &amp;&amp; echo &quot;yes&quot;</p>
<p>【3】、整数值比较<br>
-eq：等于（Equal）         Equal：相同的，同等的                               greate：较大的        than：就，（多、小、少）于              lesser： 较小的<br>
-ne：不等于（Not Equal）<br>
-gt：大于（Greater Than）<br>
-lt：小于（Lesser Than）<br>
-le：小于或等于（Lesser or Equal）<br>
-ge：大于或等于（Greater or Equal）</p>
<p>[root@lala ~]# [ 1 -eq 2 ]<br>
[root@lala ~]# echo $?<br>
1-255<br>
[root@lala ~]# [ 1 -eq 1 ]<br>
[root@lala ~]# echo $?<br>
0</p>
<p>例：测试用户输入的值是否大于100<br>
例：（脚本）<br>
#!/bin/bash<br>
stty -echo<br>
read -p &quot;请输入一个数值：&quot; num<br>
printf &quot;\n&quot;<br>
stty echo<br>
printf &quot;\n&quot;<br>
[ $num -gt 100 ] &amp;&amp; echo &quot;数值大于100&quot; || echo &quot;数值小于100&quot;</p>
<p>例：判断磁盘使用量<br>
[root@lala ~]# df -hT<br>
文件系统            类型      容量  已用  可用 已用% 挂载点<br>
/dev/mapper/cl-root xfs        97G  4.1G   93G    5% /<br>
devtmpfs            devtmpfs  897M     0  897M    0% /dev<br>
tmpfs               tmpfs     912M  144K  912M    1% /dev/shm<br>
tmpfs               tmpfs     912M   17M  895M    2% /run<br>
tmpfs               tmpfs     912M     0  912M    0% /sys/fs/cgroup<br>
/dev/sda1           xfs       197M  150M   47M   77% /boot<br>
tmpfs               tmpfs     183M   16K  183M    1% /run/user/0<br>
/dev/sr0            iso9660   4.1G  4.1G     0  100% /media/dvd<br>
[root@lala ~]# df -hT | grep &quot;/boot<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 75: …t
[root@lala ~]#̲ df -hT | grep …'>&quot;
/dev/sda1           xfs       197M  150M   47M   77% /boot
[root@lala ~]# df -hT | grep &quot;/boot</span>&quot; | awk '{print <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 2: 6}̲&#039;
77%
[root@lal…'>6}&#039;
77%
[root@lala ~]# df -hT | grep &quot;/boot</span>&quot; | awk '{print $6}' | cut -d% -f1<br>
77<br>
[root@lala ~]# [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><mo>−</mo><mi>h</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(df -hT | grep &quot;/boot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord">&quot;</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>&quot; | awk '{print $6}' | cut -d% -f1) -ge 60 ] &amp;&amp; echo &quot;too many&quot;<br>
too many</p>
<p>例：判断内存<br>
[root@lala ~]# free<br>
total        used        free      shared  buff/cache   available<br>
Mem:        1867264      581368      324024       19444      961872     1033020<br>
Swap:       2097148           0     2097148<br>
[root@lala ~]# free | grep &quot;Mem:&quot;<br>
Mem:        1867264      581740      323652       19444      961872     1032680<br>
[root@lala ~]# free | grep &quot;Mem:&quot; | awk '{print <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 2: 4}̲&#039;
323388
[root@…'>4}&#039;
323388
[root@lala ~]# b=</span>(free | grep &quot;Mem:&quot; | awk '{print $4}')<br>
[root@lala ~]# [ $b -lt 500000 ] &amp;&amp; echo ${b}MB</p>
<p>【4】、字符串比较<br>
=:字符串相同<br>
!=：字符串不同（! 号表示相反的意思）<br>
-z：字符串是否为空</p>
<p>例：<br>
[root@lala ~]# echo $LANG<br>
zh_CN.UTF-8<br>
[root@lala ~]# [ $LANG != &quot;zh_CN.UTF-8&quot; ] &amp;&amp; echo &quot;不是中文&quot; || echo &quot;中文&quot;<br>
中文</p>
<p>例：<br>
[root@lala ~]# read -p &quot;Do you love me?(yes/no)&quot; ack<br>
Do you love me?(yes/no)yes<br>
[root@lala ~]# [ $ack = &quot;yes&quot; ] &amp;&amp; echo &quot;I love you too&quot; || echo &quot;But I love you very much&quot;<br>
I love you too<br>
[root@lala ~]# [ $ack = &quot;no&quot; ] &amp;&amp; echo &quot;I love you too&quot; || echo &quot;But I love you very much&quot;<br>
But I love you very much<br>
例：<br>
[root@localhost ~]# [ -z ]<br>
[root@localhost ~]# echo $?<br>
0<br>
[root@localhost ~]# [ -z 123456 ]<br>
[root@localhost ~]# echo $?<br>
1<br>
特殊示例：<br>
a=               {变量值不能为空}<br>
b=123.com<br>
[ $a = $b ]<br>
echo $?<br>
2<br>
[root@localhost ~]# [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">a=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>b ]        //不加空格相当等式了！！！<br>
[root@localhost ~]# echo $?<br>
0</p>
<p>【5】、逻辑测试<br>
-a或&amp;&amp;：逻辑与（and）         #多个测试条件进行链接，当前面的测试条件满足时，进行后面的条件测试<br>
-o或||    ：逻辑或/否则（or）  #多个测试条件满足任意一个（[ $a -lt 90 ] || [ $a -ge 80 ] ）<br>
！          ：逻辑非（取反）<br>
应用环境：||一般用于多个&amp;&amp;测试条件之后，当前面的测试都不满足时，最后默认生效的测试。<br>
num=101<br>
[ $num -gt 100 ] &amp;&amp; echo &quot;数值大于100&quot; || echo &quot;数值小于100&quot;</p>
<p>例：<br>
[root@lala ~]# [ $USER != root ] &amp;&amp; echo &quot;not root&quot; || echo &quot;hello good man&quot;<br>
hello good man<br>
[root@lala ~]# [ $USER = root ] &amp;&amp; echo &quot;hello muhuaijun is a good man&quot; || echo &quot;not root&quot;<br>
hello muhuaijun is a good man</p>
<p>例：判断用户是否存在<br>
[root@lala ~]# id<br>
uid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023<br>
[root@lala ~]# id abc<br>
id: abc: no such user<br>
写一个脚本，检查用户abc是否存在，如果存在，则显示“abc is user”，如果不存在则创建<br>
vim useradd.sh<br>
#!/bin/bash<br>
id abc &amp;&gt; /dev/null &amp;&amp; echo &quot;abc is user&quot; || useradd abc</p>
<p>[root@lala ~]# sh useradd.sh<br>
[root@lala ~]# tail -1 /etc/passwd<br>
abc：x：1001:1001::/home/abc:/bin/bash</p>
<h1 id="例rootlala-~-vim-diskshbinbashdiskuserdf-ht-grep-boot-awk-print-6-cut-d-f1-diskuser-ge-60-echo-space-is-low-echo-space-is-muchrootlala-~-sh-diskshspace-is-low例rootlocalhost-~-z-pass1-rootlocalhost-~-echo-1rootlocalhost-~-pass14566rootlocalhost-~-z-pass1-rootlocalhost-~-echo-0">例：<br>
[root@lala ~]# vim disk.sh<br>
#!/bin/bash<br>
diskuser=<code>df -hT | grep &quot;/boot$&quot; | awk '{print $6}' | cut -d% -f1</code><br>
[ $diskuser -ge 60 ] &amp;&amp; echo &quot;space is low&quot; || echo &quot;space is much&quot;<br>
[root@lala ~]# sh disk.sh<br>
space is low<br>
例：<br>
[root@localhost ~]# ! [ -z $pass1 ]<br>
[root@localhost ~]# echo $?<br>
1<br>
[root@localhost ~]# pass1=4566<br>
[root@localhost ~]# ! [ -z $pass1 ]<br>
[root@localhost ~]# echo $?<br>
0</h1>
<p><font color=#0000FF><strong>练习</strong></font></p>
<p>1、测试/opt/backup目录是否存在<br>
[root@lala ~]# vim di.sh<br>
#!/bin/bash<br>
[ -d /opt/backup ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</p>
<p>[root@lala ~]# sh di.sh<br>
no</p>
<p>2、查询当前的活动进程数，并测试是否小于100<br>
[root@lala ~]# vim ps.sh<br>
#!/bin/bash<br>
<font color="#dddd00">pss=$(ps aux | wc -l)</font><br /><br>
[ $pss -lt 100 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;<br>
[root@lala ~]# sh ps.sh<br>
no</p>
<p>3、测试是否已经安装sysstat软件包<br>
[root@lala ~]# vim sys.sh<br>
#!/bin/bash<br>
rpm -qa sysstat &amp;&gt; /dev/null<br>
<font color="#dddd00">a=$(echo $?)</font><br /><br>
[ $a -ne 0 ] &amp;&amp; echo &quot;not installed&quot; || echo &quot;installed&quot;</p>
<h1 id="4-测试user1是否存在若不存在则创建rootlala-~-vim-users2shbinbashid-user1-devnull-echo-有此用户-echo-正在创建此用户-useradd-user1-id-user10-devnull-useradd-user10-echo-user10-passwd-stdin-123com-devnull-echo-user10-shigeyonghu-id-user20-devnull-useradd-user20-echo-user20-passwd-stdin-123com-devnull-echo-user20-shigeyonghu-id-user30-devnull-useradd-user30-echo-user30-passwd-stdin-123com-devnull-echo-user30-shigeyonghu-id-user40-devnull-useradd-user40-echo-user40-passwd-stdin-123com-devnull-echo-user40-shigeyonghu-id-user50-devnull-useradd-user50-echo-user50-passwd-stdin-123com-devnull-echo-user50-shigeyonghu">4、测试user1是否存在，若不存在则创建<br>
[root@lala ~]# vim users2.sh<br>
#!/bin/bash<br>
id user1 &amp;&gt; /dev/null &amp;&amp; echo 有此用户 || echo 正在创建此用户 &amp;&amp; useradd user1<br>
! id user10 &amp;&gt; /dev/null &amp;&amp; useradd user10 &amp;&amp; echo &quot;user10&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user10 shigeyonghu&quot;<br>
! id user20 &amp;&gt; /dev/null &amp;&amp; useradd user20 &amp;&amp; echo &quot;user20&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user20 shigeyonghu&quot;<br>
! id user30 &amp;&gt; /dev/null &amp;&amp; useradd user30 &amp;&amp; echo &quot;user30&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user30 shigeyonghu&quot;<br>
! id user40 &amp;&gt; /dev/null &amp;&amp; useradd user40 &amp;&amp; echo &quot;user40&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user40 shigeyonghu&quot;<br>
! id user50 &amp;&gt; /dev/null &amp;&amp; useradd user50 &amp;&amp; echo &quot;user50&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user50 shigeyonghu&quot;</h1>
<p>if语句结构<br>
if……then……：如果……那么……</p>
<p>每个if语句都要用fi结束，而且是每一个if都要对应一个fi。<br>
整个if语句用fi闭合起来才算完整，书写时if和fi要垂直对齐以方便查看。</p>
<p>格式举例：<br>
if  condition                                   condition：状态<br>
then<br>
    command1<br>
    command2                                command：命令，指令<br>
fi</p>
<p>condition是判断条件，如果 condition 成立（返回“真”），那么 then 后边的语句将会被执行；如果 condition 不成立（返回“假”），那么不会执行任何语句。最后必须以fi来闭合，fi 就是 if 倒过来拼写，即使有多条语句也不需要用{ }包围起来。</p>
<p><font color="#00dd00"><strong>【1】单分支语法格式（两种写法）</strong></font><br /><br>
if  条件测试操作	                              	if  条件测试操作；then 命令序列<br>
then 命令序列    	                             	      fi<br>
fi<br>
解析：【1】如果if和then在同一行，必有;       【2】不在一行;可以省略！！！<br>
<font color="#dd0000">单分支执行流程：<br>
1）首先判断条件测试操作的结果。<br>
2）如果返回值为0，表示条件成立，则执行then后面的命令序列，一直到遇见fi结束判断为止，继续执行其他脚本代码；<br>
3）如果返回值不为0，则忽略then后面的命令序列，直接跳转至fi行以后执行其他脚本代码。</font><br /></p>
<p>例：<br>
[root@localhost ~]# vim mount.sh<br>
#!/bin/bash<br>
mou=&quot;/var/www/html&quot;<br>
if [ ! -d $mou ]<br>
then<br>
mkdir -p $mou<br>
fi</p>
<p>例：<br>
[root@localhost ~]# vim us.sh<br>
#!/bin/bash<br>
if [ $USER != &quot;abc&quot; ]<br>
then<br>
echo &quot;abc is not user&quot;                //执行脚本，返回abc is not user（如果有abc用户，将什么都不显示！）<br>
fi<br>
<font color="#00dd00"><strong>【2】双分支语法格式</strong></font><br /><br>
判断条件表达式中的结果是否满足，如果满足条件则执行命令序列1，如果不满足条件，则执行命令序列2。</p>
<p>语法格式：<br>
if [ 条件测试操作 ];then                                                                      then：接着，当时                else：其他的，另外的<br>
满足条件后执行的语句 （命令序列1）<br>
else<br>
不满足添加后执行的语句（命令序列2）<br>
fi<br>
<font color="#dd0000"><strong>注：else在一组if语句中只能使用一次。<br>
在程序或脚本中，大部分的逻辑判断都是使用双分支语句。</strong></font><br /><br>
<font color="#dd0000">执行流程：</br><br>
1）首先判断条件测试操作的结果！</br><br>
2）如果条件成立，则执行then后面的命令序列1，忽略else及后面的命令序列2，直到遇见fi结束判断；</br><br>
3）如果条件不成立，则忽略then及后面的命令序列1，直接跳至else后面的命令序列2，直到遇见fi结束判断。</font><br /></p>
<p>例：<br>
[root@localhost www]# vim httpd.sh<br>
#!/bin/bash<br>
netstat -anpt | grep 80<br>
a=<code>echo $?</code><br>
if [ $a -eq 0 ];then<br>
echo &quot;httpd is running&quot;<br>
else<br>
systemctl restart httpd &amp;&amp; echo &quot;httpd is run!!!&quot;<br>
fi</p>
<p>例：<br>
[root@localhost www]# vim ping.sh<br>
#!/bin/bash<br>
ping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/null<br>
if [ $? -eq 0 ]<br>
then<br>
echo &quot;host $1 is up&quot;<br>
else<br>
echo &quot;host $1 is down&quot;<br>
fi</p>
<p>-c    3:只发送3个测试包<br>
-i    0.2：间隔0.2秒<br>
-W     3：超时3秒<br>
$1：位置变量，如果改成$2，则要写两个ip地址，第一个不被使用，直接使用第二个</p>
<p>[root@localhost www]# chmod +x ping.sh<br>
[root@localhost www]# ./ping.sh 192.168.6.20</p>
<p><font color="#00dd00"><strong>【3】多分支语句结构</strong></font><br /><br>
判断条件中，多于两个以上的对比值，使用多分支判断，对不用值的语句调用。<br>
if  条件测试操作1<br>
then 命令序列1<br>
elif 条件测试操作2                               elif：否则如果<br>
then 命令序列2<br>
else  命令序列3<br>
fi<br>
<font color="#dd0000">执行流程：</br><br>
1）首先判断条件测试操作1的结果，如果条件1成立，则执行命令序列1，然后跳至fi结束判断；</br><br>
2）如果条件1不成立，则继续判断条件测试操作2的结果，如果条件2成立，则执行命令序列2，然后跳至fi结束判断……0</br><br>
3）如果所有条件都不满足，则执行then及后面的命令序列n，直接跳至else后面的命令序列2，直到遇见fi结束判断。</td></tr></font><br /></p>
<p>例：<br>
vim name.sh<br>
#!/bin/bash<br>
read -p &quot;what's your name?(xuesenwei,lianpeng,yuxinyu,boge):&quot;  name<br>
if [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>x</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>w</mi><mi>e</mi><mi>i</mi><mi mathvariant="normal">&quot;</mi><mo>]</mo><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">name = &quot;xuesenwei&quot; ]
then
echo &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mord mathdefault">x</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>name is pig&quot;<br>
elif [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>l</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">&quot;</mi><mo>]</mo><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">name = &quot;lianpeng&quot; ]
then
echo &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>name is monkey&quot;<br>
elif [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>y</mi><mi>u</mi><mi>x</mi><mi>i</mi><mi>n</mi><mi>y</mi><mi>u</mi><mi mathvariant="normal">&quot;</mi><mo>]</mo><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">name = &quot;yuxinyu&quot; ]
then
echo &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">u</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>name is dashu&quot;<br>
else<br>
echo &quot;$name is niu&quot;<br>
fi</p>
<p>[root@lala ~]# sh name.sh<br>
what's your name?(xuesenwei,lianpeng,yuxinyu,boge):yuxinyu<br>
yuxinyu is dashu</p>
<p>例：<br>
[root@lala ~]# vim fen.sh           --书上的示例<br>
#!/bin/bash<br>
read -p &quot;qing shu ru nin de fen shu(0-100):&quot;    fenshu<br>
if<br>
[ $fenshu -ge 85 ] &amp;&amp; [ $fenshu -le 100 ];<br>
then<br>
echo &quot;chengji is couhe&quot;<br>
elif<br>
[ $fenshu -ge 70 ] &amp;&amp; [ $fenshu -le 84 ];<br>
then<br>
echo &quot;chengji is youxiu&quot;<br>
elif<br>
[ $fenshu -ge 60 ] &amp;&amp; [ $fenshu -le 69 ];<br>
then<br>
echo &quot;chengji is hege&quot;<br>
else<br>
echo &quot;chengji is bujige&quot;<br>
fi</p>
<h2 id="rootlala-~-sh-fenshqing-shu-ru-nin-de-fen-shu0-10085chengji-is-couherootlala-~-sh-fenshqing-shu-ru-nin-de-fen-shu0-10074chengji-is-youxiu">[root@lala ~]# sh fen.sh<br>
qing shu ru nin de fen shu(0-100):85<br>
chengji is couhe<br>
[root@lala ~]# sh fen.sh<br>
qing shu ru nin de fen shu(0-100):74<br>
chengji is youxiu</h2>
<p><font size="4"><strong>判断分数范围，分出优秀、合格、不合格三档（中文版）</strong></font><br>
<font color="#0000dd"><br>
#!/bin/bash<br>
read -p 请输入成绩： a<br>
if [ $a -le 100 ] &amp;&amp;  [ $a -ge 90 ]<br>
then   echo 优<br>
elif [ $a -lt 90 ] &amp;&amp; [ $a -ge 80 ]<br>
then echo 良<br>
elif [ $a -lt 80 ] &amp;&amp; [ $a -ge 70 ]; then<br>
echo 好<br>
elif [ $a -lt 70 ] &amp;&amp; [ $a -ge 60 ];then echo 合格<br>
elif [ $a -ge 100 ];<br>
then echo 你牛逼<br>
else<br>
echo 不合格<br>
fi<br>
[root@localhost ~]# source 1.sh<br>
请输入成绩：105<br>
你牛逼<br>
[root@localhost ~]# source 1.sh<br>
请输入成绩：35<br>
不合格<br>
[root@localhost ~]# source 1.sh<br>
请输入成绩：85<br>
良</font><br /></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7安装VMware-Tools]]></title>
        <id>https://www.zhz666.cf/post/centos7-an-zhuang-vmware-tools/</id>
        <link href="https://www.zhz666.cf/post/centos7-an-zhuang-vmware-tools/">
        </link>
        <updated>2020-11-24T00:24:02.000Z</updated>
        <content type="html"><![CDATA[<p>1、配置yum源😎<br>
rm -f /etc/yum.repos.d/*<br>
vim /etc/yum.repos.d/yum.repo</p>
<p>2、挂载系统光盘<br>
umount /dev/sr0<br>
mount /dev/sr0 /media<br>
cd /media/Packages/</p>
<p>3、安装组件与依赖关系<br>
yum -y install gcc gcc-c++ perl make kernel-haders kernel-devel</p>
<p>4、卸载系统自带工具<br>
rpm -qa | grep vm-tools<br>
rpm -e open-vm-tools open-vm-tools-desktop --nodeps</p>
<p>5、建立内核版本文件软连接文件<br>
ln -s /usr/src/kernels/3.10.0-514.el7.x86_64/include/generated/uapi/linux/version.h /usr/src/kernels/3.10.0-514.el7.x86_64/include/linux/version.h</p>
<p>6、关闭防火墙与selinux<br>
vim /etc/selinux/config<br>
修改：<br>
SELINUX=disabled</p>
<p>setenforce 0<br>
systemctl disable firewalld.service<br>
systemctl stop firewalld.service<br>
reboot</p>
<p>7、挂载vmware-tools光盘，解压软，并安装软件<br>
tar -zxvf VMwareTools-10.0.0-2977863.tar.gz -C /tmp<br>
cd /tmp/vmware-tools-distrib/<br>
./vmware-install.pl<br>
reboot<br>
😎😎😎😎😎😎😎😎😎😎😎</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=442314991&auto=1&height=66"></iframe>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的世界]]></title>
        <id>https://www.zhz666.cf/post/wo-de-shi-jie/</id>
        <link href="https://www.zhz666.cf/post/wo-de-shi-jie/">
        </link>
        <updated>2020-11-15T05:36:15.000Z</updated>
        <content type="html"><![CDATA[<iframe  class="music" frameborder="no" src="//music.163.com/outchain/player?type=1&id=89680147&auto=1&height=90"></iframe>
>en						用户模式
#conf t						特权模式
(config)#int f0/0					全局模式
(config-if)#					接口模式
#disable  →>
(config)#hostname  name				修改主机名
<p>switch(config)#vlan vlan-number			划分VLAN<br>
switch(config-vl)#name vlan-name			vlan命名<br>
switch(config)#int range f0/1-5			同时进入f0/1-5端口<br>
Switch(config-if-range)#switchport mode access		把端口设置成接入链路<br>
Switch(config-if-range)#switchport access vlan 2		把端口加入到vlan2<br>
switch(config-if-range)#switchport mode trunk		把端口设置成中继链路<br>
switch(config-if-range)#channel-group 1 mode on 	把几个端口捆绑成以太网通道1<br>
switch(config)#vtp domain vtp-name			设置VTP名称<br>
switch(config)#vtp password vtp-password		设置VTP密码<br>
switch(config)#vtp mode server|client			设置成VTP服务器|客户端<br>
switch(config)#ip default-gateway 默认网关		设置交换机默认网关	<br>
(config)#enable secret pwd1				设置特权模式密码(密文)<br>
(config)#enable password pwd1			设置特权模式密码(明文)<br>
(config)#service password-encryption			对明文密码加密<br>
(config-if)#ip address IP地址 子网掩码 			设置IP地址(交换机的IP地址只能设置在虚拟端口vlan上)<br>
(config-if)#no shutdown				手动开启端口<br>
(config)#line vty 0 4				开启0~4端口(一共5个)<br>
(config)#password vty-password			设置vty密码<br>
(config)#login					开启登录模式<br>
(config)#line console 0 				进入配置口<br>
(config)#password con-password			设置配置口密码<br>
(config)#login					开启登录模式<br>
vty		远程访问的时候需要<br>
console		直接用配置线对设备配置时需要<br>
router(config)#ip route 目标网段 子网掩码 IP地址|端口号 num	设置静态路由<br>
router(config)#ip route 192.168.6.0 255.255.255.0 f0/1<br>
IP地址指向下一个路由器(下一个路由器接收口的IP地址)<br>
端口号指自身的端口(当前路由器的出口)<br>
num数值1~255  数值越小优先级越高<br>
目标网段 不能是具体IP地址(192.168.10.0      2.0.0.0)<br>
router(config)#ip dhcp pool dhcp-name		设置DHCP并命名<br>
router(dhcp-config)#network 分配的网段 子网掩码		设置地址池<br>
分配的网段  (192.168.5.0  6.0.0.0)<br>
router(dhcp-config)#default-router 默认网关		DHCP分配的默认网关<br>
router(config)#int f 0/0.1				进入子端口<br>
f0/0.1指 f0/0的第一个子端口<br>
f0/1.2指 f0/1的第二个子端口<br>
Router(config-subif)#en do vlan-number		把子端口绑定到vlan<br>
Router(config-subif)#en do 2				把子端口绑定到vlan2</p>
<p>telnet 目标IP地址					PC上远程访问设备<br>
#reload						正常使用时重启<br>
#show running-config				查看运行时配置<br>
#show startup-config				查看保存的配置<br>
(config)#do show running-config			其他模式下查看前面+do</p>
<p>#copy running-config startup-config			把当前配置保存到NVRAM<br>
#write						保存运行时配置(效果同上)<br>
#copy startup-config running-config			用NVRAM覆盖当前配置</p>
<p>#erase nvram: 					删除保存的配置</p>
<p>#copy tftp flash					从TFTP服务器下载系统到路由器	<br>
#copy flash tftp					从路由器上传系统到服务器<br>
(config)#ip ftp username s1t161			在路由器上设置ftp的用户名<br>
(config)#ip ftp password s1t161			在路由器上设置ftp的密码</p>
<p>rommon 1 &gt; tftpdnld     				(download)<br>
rommon 2 &gt; IP_ADDRESS=1.1.1.1			设置路由器的IP地址<br>
rommon 3 &gt; IP_SUBNET_MASK=255.0.0.0		设置路由器的子网掩码<br>
rommon 4 &gt; DEFAULT_GATEWAY=1.2.2.2		设置路由器的默认网关(TFTP的IP地址)<br>
rommon 5 &gt; TFTP_SERVER=1.2.2.2			设置下载系统的原位置的IP地址(TFTP的IP地址)<br>
rommon 6 &gt; TFTP_FILE=c1841-ipbasek9-mz.124-12.bin	设置要下载的文件名<br>
rommon 7 &gt; tftpdnld</p>
<p>Do you wish to continue? y/n:  [n]:  y			输入y继续<br>
rommon 8 &gt; reset					重启<br>
😙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://www.zhz666.cf/post/hello-gridea/</id>
        <link href="https://www.zhz666.cf/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>