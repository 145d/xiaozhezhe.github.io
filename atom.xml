<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.zhz666.cf</id>
    <title>欢迎来到德莱联盟</title>
    <updated>2020-12-13T05:55:02.046Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.zhz666.cf"/>
    <link rel="self" href="https://www.zhz666.cf/atom.xml"/>
    <subtitle>笑着面对生活，爱你呦~</subtitle>
    <logo>https://www.zhz666.cf/images/avatar.png</logo>
    <icon>https://www.zhz666.cf/favicon.ico</icon>
    <rights>All rights reserved 2020, 欢迎来到德莱联盟</rights>
    <entry>
        <title type="html"><![CDATA[什么是repo文件？ ]]></title>
        <id>https://www.zhz666.cf/post/shi-me-shi-repo-wen-jian/</id>
        <link href="https://www.zhz666.cf/post/shi-me-shi-repo-wen-jian/">
        </link>
        <updated>2020-12-13T04:35:52.000Z</updated>
        <content type="html"><![CDATA[<p>repo文件是Fedora中yum源（软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用！<br>
YUM的工作原理并不复杂，每一个 RPM软件的头（header）里面都会纪录该软件的依赖关系，那么如果可以将该头的内容纪录下来并且进行分析，可以知道每个软件在安装之前需要额外安装 哪些基础软件。也就是说，在服务器上面先以分析工具将所有的RPM档案进行分析，然后将该分析纪录下来，只要在进行安装或升级时先查询该纪录的文件，就可 以知道所有相关联的软件。所以YUM的基本工作流程如下：</p>
<h2 id="服务器端在服务器上面存放了所有的rpm软件包然后以相关的功能去分析每个rpm文件的依赖性关系将这些数据记录成文件存放在服务器的某特定目录内-客户端如果需要安装某个软件时先下载服务器上面记录的依赖性关系文件可通过www或ftp方式通过对服务器端下载的纪录数据进行分析然后取得所有相关的软件一次全部下载下来进行安装">服务器端：在服务器上面存放了所有的RPM软件包，然后以相关的功能去分析每个RPM文件的依赖性关系，将这些数据记录成文件存放在服务器的某特定目录内。<br>
客户端：如果需要安装某个软件时，先下载服务器上面记录的依赖性关系文件(可通过WWW或FTP方式)，通过对服务器端下载的纪录数据进行分析，然后取得所有相关的软件，一次全部下载下来进行安装。</h2>
<p>rpm    --nodeps：安装时忽略依赖关系。<br>
缺少依赖关系，导致部分软件不能正常使用<br>
yum：由redhat推出的服务，rpm包管理器，对依赖数据包进行更新安装工具</p>
<p>yum主配置目录：/etc/yum.repos.d/<br>
yum主配置文件:  /etc/yum.conf<br>
YUM主配文件:/etc/yum.conf</p>
<h2 id="font-colordd0000yum重要的目录和文件fontpackages存储rpm包repodata记录软件依赖关系cd-repodatarepomdxml-xml列表-查找软件依赖关系"><font color="#dd0000">yum重要的目录和文件：</font><br>
Packages	存储rpm包<br>
repodata	记录软件依赖关系<br>
cd repodata→repomd.xml  （xml列表 查找软件依赖关系）</h2>
<p>[root@localhost ~]# ll /etc/yum.repos.d/<br>
总用量 28<br>
-rw-r--r--. 1 root root 1664 11月 30 2016 CentOS-Base.repo                                           //联网后基础的源<br>
-rw-r--r--. 1 root root 1309 11月 30 2016 CentOS-CR.repo<br>
-rw-r--r--. 1 root root  649 11月 30 2016 CentOS-Debuginfo.repo                                    //和内核相关的更新和软件安装<br>
-rw-r--r--. 1 root root  314 11月 30 2016 CentOS-fasttrack.repo<br>
-rw-r--r--. 1 root root  630 11月 30 2016 CentOS-Media.repo                                               //使用光盘挂载后调用的文件<br>
-rw-r--r--. 1 root root 1331 11月 30 2016 CentOS-Sources.repo<br>
-rw-r--r--. 1 root root 2893 11月 30 2016 CentOS-Vault.repo                                                   //最近新版本的加入的（老版本的yum源配置）<br>
工作原理！<br>
yum通过读取yum源配置文件，确认软件包源文件路径，读取路径中，两个目录中的文件信息。<br>
1.repodata目录：软件包依赖环境参照表。目录中有*.xml文件，文件中记录了软件的依赖环境。<br>
2.Packages目录：统计完需要安装的依赖关系后，从此目录中读取相关软件包。<br>
3.将软件包复制到缓存后，进行解压安装。</p>
<h1 id="font-color00dddd-size5第一部分font"><font color="#00dddd" size=5>第一部分：</font></h1>
<p>vim  /etc/yum.conf<br>
[main]<br>
cachedir=/var/cache/yum/$ basearch/$ releasever          #cachedir：yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum/$ basearch/$ releasever。</p>
<p><font color="#dd0000">keepcache=1<br>
#keepcache：是否保留缓存内容，0：表示安装后删除软件包，1表示安装后保留软件包</font></p>
<p>debuglevel=2<br>
#debuglevel：除错级别，0──10,默认是2 貌似只记录安装和删除记录<br>
logfile=/var/log/yum.log<br>
pkgpolicy=newest<br>
#pkgpolicy： 包的策略。一共有两个选项，newest和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository中同时存 在，yum应该安装哪一个，如果是newest，则yum会安装最新的那个版本。如果是last，则yum会将服务器id以字母表排序，并选择最后的那个 服务器上的软件安装。一般都是选newest。</p>
<p>distroverpkg=centos-release<br>
#指定一个软件包，yum会根据这个包判断你的发行版本，默认是redhat-release，也可以是安装的任何针对自己发行版的rpm包。</p>
<p>tolerant=1<br>
#tolerent，也有1和0两个选项，表示yum是否容忍命令行发生与软件包有关的错误，比如你要安装1,2,3三个包，而其中3此前已经安装了，如果你设为1,则yum不会出现错误信息。默认是0。<br>
exactarch=1<br>
#exactarch，有两个选项1和0,代表是否只升级和你安装软件包cpu体系一致的包，如果设为1，则如你安装了一个i386的rpm，则yum不会用1686的包来升级。</p>
<p>retries=20<br>
#retries，网络连接发生错误后的重试次数，如果设为0，则会无限重试。<br>
obsoletes=1<br>
<font color="#dd0000">gpgcheck=1<br>
#gpgchkeck= 有1和0两个选择，分别代表是否是否进行gpg校验，如果没有这一项，默认是检查的。 </font><br>
reposdir=/etc/yy.rm #默认是 /etc/yum.repos.d/ 低下的 xx.repo后缀文件<br>
#默认都会被include 进来 也就是说 /etc/yum.repos.d/xx.repo 无论配置文件有多少个 每个里面有多少个[name] 最后其实都被整合到 一个里面看就是了 重复的[name]后面的覆盖前面的<br>
exclude=xxx<br>
#exclude 排除某些软件在升级名单之外，可以用通配符，列表中各个项目要用空格隔开，这个对于安装了诸如美化包，中文补丁的朋友特别有用。<br>
keepcache=[1 or 0]<br>
#　　设置 keepcache=1，yum 在成功安装软件包之后保留缓存的头文件 (headers) 和软件包。默认值为 keepcache=0 不保存</p>
<p>reposdir=[包含 .repo 文件的目录的绝对路径]<br>
#　　该选项用户指定 .repo 文件的绝对路径。.repo 文件包含软件仓库的信息 (作用与 /etc/yum.conf 文件中的 [repository] 片段相同)。</p>
<h1 id="font-color00dddd-size5第二部分font"><font color="#00dddd" size=5>第二部分：</font></h1>
<p>vi /etc/yum.repo.d/xx.repo<br>
这个字段其实也可以在yum.conf里面直接配置</p>
<p>[serverid]<br>
#其中serverid是用于区别各个不同的repository，必须有一个独一无二的名称。 重复了 前面覆盖后面--还是反过来呢？？？用enabled 测试是后面覆盖前面<br>
name=Some name for this server<br>
#name，是对repository的描述，支持像$releasever $basearch这样的变量; name=Fedora Core $releasever - $basearch - Released Updates</p>
<p><font color="#dd0000">baseurl=url://path/to/repository/<br>
#baseurl是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。它的格式是： </font><br>
baseurl=url://server1/path/to/repository/<br>
url://server2/path/to/repository/<br>
url://server3/path/to/repository/<br>
#其中url支持的协议有 http:// ftp:// file://三种。baseurl后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl只能有一个，也就是说不能像如下格式：<br>
<font color="#00dd00">baseurl=url://server1/path/to/repository/<br>
baseurl=url://server2/path/to/repository/<br>
baseurl=url://server3/path/to/repository/    </font><br>
其中url指向的目录必须是这个repository header目录的上一级，它也支持$releasever $basearch这样的变量。</p>
<p>#mirrorlist=http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 11: releasever&amp;̲arch='>releasever&amp;arch=</span>basearch<br>
#上面的这一行是指定一个镜像服务器的地址列表，通常是开启的，本例中加了注释符号禁用了，我们可以试试，将$ releasever和$ basearch替换成自己对应的版本和架构，例如10和i386，在浏览器中打开，我们就能看到一长串镜可用的镜像服务器地址列表。</p>
<p><font color="#dd00dd">url之后可以加上多个选项，如gpgcheck、exclude、failovermethod等，比如：</font><br>
gpgcheck=1<br>
exclude=gaim<br>
#其中gpgcheck，exclude的含义和[main]部分相同，但只对此服务器起作用，<br>
failovermethod=priority<br>
#failovermethode 有两个选项roundrobin和priority，意思分别是有多个url可供选择时，yum选择的次序，roundrobin是随机选择，如果连接失 败则使用下一个，依次循环，priority则根据url的次序从第一个开始。如果不指明，默认是roundrobin。</p>
<p>enabled=[1 or 0]<br>
#当某个软件仓库被配置成 enabled=0 时，yum 在安装或升级软件包时不会将该仓库做为软件包提供源。使用这个选项，可以启用或禁用软件仓库。<br>
#通过 yum 的 --enablerepo=[repo_name] 和 --disablerepo=[repo_name] 选项，或者通过 PackageKit 的&quot;添加/删除软件&quot;工具，也能够方便地启用和禁用指定的软件仓库</p>
<p><font face="楷体" size=5><font color="#dd00dd">几个变量 </font></font><br>
$ releasever，发行版的版本，从[main]部分的distroverpkg获取，如果没有，则根据redhat-release包进行判断。<br>
$ arch，cpu体系，如i686,athlon等<br>
$basearch，cpu的基本体系组，如i686和athlon同属i386，alpha和alphaev6同属alpha。<br>
对yum.conf设定完成，我们就可以好好体验yum带来的方便了。</p>
<p>还有一件事没有做。那就是导入每个reposity的GPG key，前面说过，yum可以使用gpg对包进行校验，确保下载包的完整性，所以我们先要到各个repository站点找到gpg key，一般都会放在首页的醒目位置，一些名字诸如 RPM-GPG-KEY.txt之类的纯文本文件，把它们下载，然后用rpm --import xxx.txt命令将它们导入，最好把发行版自带GPG-KEY也导入。<br>
rpm --import /usr/share/doc/redhat-release-*/RPM-GPG-KEY 官方软件升级用的上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Yum库的搭建]]></title>
        <id>https://www.zhz666.cf/post/yum-ku-de-da-jian/</id>
        <link href="https://www.zhz666.cf/post/yum-ku-de-da-jian/">
        </link>
        <updated>2020-12-13T03:34:25.000Z</updated>
        <summary type="html"><![CDATA[<p><font color="#dd0000" size=5.5>（一）yum介绍</font><br>
<a href="https://baike.baidu.com/item/yum/2835771?fr=aladdin"><font color="#00dddd">yum库参考</font></a><br>
Yum(全称为 Yellow dogUpdater, Modified)是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
]]></summary>
        <content type="html"><![CDATA[<p><font color="#dd0000" size=5.5>（一）yum介绍</font><br>
<a href="https://baike.baidu.com/item/yum/2835771?fr=aladdin"><font color="#00dddd">yum库参考</font></a><br>
Yum(全称为 Yellow dogUpdater, Modified)是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<!-- more -->
<p><font color="#dd0000" size=5>（二）yum源实验</font><br>
使用YUM机制来更新系统和软件，需要有一个包含各种rpm安装包文件及其依赖的软件仓库（repository），提供软件仓库的服务器也称为“源”服务器。<br>
在客户机中只要正确指定软件仓库的地址等信息，就可以通过对应的“源”服务器来安装或更新软件了。<br>
1、yum<br>
使用rpm安装的软件有一个很大的弊端，在更新软件时，对依赖关系的版本号要求比较严格。yum可以帮助用户通过列表(xml)查询软件安装时所需的依赖关系，并且通过预定义的yum源下载和安装依赖关系。<br>
2、常用的yum源</p>
<p>1.本地源：在单服务器运行时常用的方式，将rpm软件包保存在本地目录中，安装软件时从本地读取文件，速度快，但更新维护比较繁琐。       将系统光盘或系统镜像文件挂载到指定目录，配置yum源。</p>
<p>2.ftp源：在公司的机房中，局域网中使用，将rpm软件包保存在ftp服务器的站点目录下，客户端配置ftp源，安装软件时可以通过ftp下载数据。ftp服务的弊端，访问并发量少，当访问用户比较多时，下载速度比较慢。</p>
<p>3.http源：使用web服务中,http协议的文件传输功能，通过广域网下载rpm软件包。便于推广，控制下载流量，并发连接数高。</p>
<p>3、更新yum仓库<br>
将新版本的rpm软件包复制到yum仓库目录中，相关的依赖关系软件包也复制到yum仓库目录中，更新xml列表文件。<br>
xml列表文件有两种更新方式：（1）手动更新（2）复制软件开发者制作的xml列表。</p>
<p><font size="4.5">【1】</font><br>
本地源：在服务器本地目录中存储rpm包<br>
优点：安装速度快<br>
缺点：只能本服务器自己使用<br>
[local]<br>
name=local<br>
baseurl=file://[目录]<br>
enabled=1                   #启用yum软件仓库<br>
gpgcheck=0                #取消gpg校验，一种密钥方式签名（默认检查）</p>
<p>例：<br>
rm -rf /etc/yum.repos.d/*<br>
vim /etc/yum.repos.d/yum.repo<br>
[yum]<br>
baseurl=file:///media/dvd<br>
enabled=1<br>
gpgcheck=0</p>
<p>mount /dev/cdrom /media/dvd（自己创建dvd目录）<br>
yum -y install httpd</p>
<p><font size="4.5">【2】</font><br>
FTP源：适用于局域网中，构建一台ftp服务器，将rpm包存储在FTP上，所有客户端的yum源指向FTP服务器<br>
优点：更新软件包时只需要更新FTP上的rpm包<br>
缺点：用户负载量低，不适用于广域网中大量的用户范围<br>
应用场景：<br>
适用于公司内部网络环境，和机房内部环境调用。不适用于广域网的原因：<br>
1.ftp用户身份验证的问题。<br>
2.ftp上下行工作机制导致传输效率比较低。<br>
3.ftp访问并发量较低。<br>
[ftp]<br>
name=ftp<br>
baseurl=ftp://ftp服务器IP地址/[目录]<br>
gpgcheck=0<br>
enabled=1</p>
<p>例：<br>
1、安装ftp服务器<br>
yum -y install vsftpd<br>
2、在FTP根目录中创建centos7的子目录<br>
默认目录/var/ftp<br>
mkdir /var/ftp/centos7                                                                     #默认匿名用户访问的“宿主根目录”为/var/ftp/目录~<br>
3、复制光盘中Packages和repodata目录到ftp根目录中（或者直接挂载到那个目录下）<br>
cp -r /media/dvd/Packages/ /var/ftp/centos7/<br>
cp -r /media/dvd/repodata/ /var/ftp/centos7/</p>
<p>systemctl restart vsftpd<br>
systemctl stop firewalld<br>
setenforce 0<br>
4、客户端配置<br>
rm -rf /etc/yum.repos.d/*<br>
[ftp]<br>
name=ftp<br>
baseurl=ftp://192.168.1.1/centos7<br>
gpgcheck=0<br>
enabled=1<br>
5、客户端测试<br>
yum -y install vsftpd<br>
yum -y install httpd<br>
yum -y remove httpd</p>
<p><font size="4.5">【3】</font><br>
HTTP源：适用于广域网，使用http服务器构建yum源。最多的一种yum仓库环境，传输速度相对比较稳定。<br>
优点：用户承载量大<br>
缺点：下载速度较慢<br>
[http]<br>
name=httpd<br>
baseurl=http://http服务器IP地址/[目录]<br>
gpgcheck=0<br>
enabled=1</p>
<p>例：<br>
1、安装httpd服务器<br>
yum -y install httpd                                                                    （注意：不能使用rpm -ivh的方式安装httpd）<br>
2、在站点根目录中创建centos7的子目录<br>
默认网页根目录/var/www/html<br>
mkdir /var/www/html/centos7<br>
3、复制光盘中Packages和repodata目录到ftp根目录中            （同理，也可以直接挂载到你创建的centos7目录）<br>
cp -r /media/dvd/Packages/ /var/www/html/centos7/       #这种方法太慢了，不如直接挂载！！！<br>
cp -r /media/dvd/repodata/ /var/www/html/centos7/</p>
<p>4.[root@localhost ~]# vim /etc/httpd/conf/httpd.conf（可省）<br>
修改：<br>
ServerName 192.168.10.1:80</p>
<p>systemctl restart httpd<br>
systemctl stop firewalld<br>
setenforce 0<br>
4、客户端配置<br>
rm -rf /etc/yum.repos.d/*<br>
[http]<br>
name=httpd<br>
baseurl=http://192.168.6.20/centos7<br>
gpgcheck=0<br>
enabled=1<br>
5、客户端测试<br>
yum -y install dhcp</p>
<p><font size="4.5">【4】CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。     【都需要虚拟机连网！！】</font><br>
<font color="#00dd00" size=5><font face="楷体">阿里源：</font></font><br>
[qwer]                                   #这个是自定义yum仓库，其实根本就不需要自定义！      因为你（下载的“源”文件会将“本地源”给覆盖掉，就可以使用了~）<br>
baseurl=https://mirrors.aliyun.com/repo/Centos-7.repo         #如果后续出错，就将这个文件下载到本地进行yum -y install makecache<br>
enable=1<br>
gpgcheck=0                           --可省了</p>
<p>Linux客户端配置方法：</p>
<ol>
<li>备份你的原镜像文件，以免出错后可以恢复<br>
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br>
2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/<br>
CentOS 7：<br>
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo<br>
或者<br>
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</li>
<li>清楚原有yum缓存   yum clean all，并运行 yum makecache 生成缓存        【可以通过yum repolist命令查看配置好的yum源是否正常】</li>
<li>其他<br>
非阿里云ECS用户会出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' 信息，不影响使用。用户也可自行修改相关配置: eg:</li>
</ol>
<p>sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo<br>
[5] 更新系统(时间比较久,主要看个人网速)  yum -y update<br>
[6] 安装vim编辑器  yum -y install vim*</p>
<p><font color="#00dd00" size=5><font face="楷体">华为源：</font></font><br>
1、备份配置文件：<br>
cp -a /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak<br>
2、两种方案，请大家自行选取。<br>
<strong>方案一：</strong><br>
下载新的CentOS-Base.repo文件到/etc/yum.repos.d/目录下，选择CentOS版本：<br>
CentOS 7<br>
执行如下命令：<br>
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.huaweicloud.com/repository/conf/CentOS-7-anon.repo</p>
<h2 id="方案二修改centos-baserepo文件取消baseurl开头的行的注释并增加mirrorlist开头的行的注释-将文件中的httpmirrorcentosorg替换成httpsmirrorshuaweicloudcom可以参考如下命令sed-i-sbaseurlbaseurlg-etcyumreposdcentos-basereposed-i-smirrorlisthttpmirrorlisthttpg-etcyumreposdcentos-basereposed-i-shttpmirrorcentosorghttpsmirrorshuaweicloudcomg-etcyumreposdcentos-baserepo3-执行yum-clean-all清除原有yum缓存-4-执行yum-makecache刷新缓存或者yum-repolist-all查看所有配置可以使用的文件会自动刷新缓存"><strong>方案二：</strong><br>
修改CentOS-Base.repo文件，取消baseurl开头的行的注释，并增加mirrorlist开头的行的注释。将文件中的http://mirror.centos.org替换成https://mirrors.huaweicloud.com，可以参考如下命令：<br>
sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo<br>
sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo<br>
sed -i &quot;s@http://mirror.centos.org@https://mirrors.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo<br>
3、执行yum clean all清除原有yum缓存。<br>
4、执行yum makecache（刷新缓存）或者yum repolist all（查看所有配置可以使用的文件，会自动刷新缓存）。</h2>
<p><font color="#0000dd" size=6>yum命令：</font><br>
增加“-y”选项，自动确认yum操作</p>
<p>yum -y install 软件名			//安装软件（常用）<br>
yum -y remove 软件名		//删除软件<br>
（只是删除本软件，不会删除依赖关系）	<br>
yum -y update			//更新软件<br>
yum info 软件名			//查看软件信息<br>
yum  list				//查看yum可用的软件列表<br>
yum -y groupinstall 软件组		//安装软件组<br>
例：<br>
yum -y groupinstall &quot;KDE&quot;</p>
<p>yum -y repolist			//查看可用yum源列表<br>
yum -y grouplist			//查看可用软件包组列表<br>
yum -y groupupdate 软件组		//更新软件组<br>
yum -y groupremove 软件组		//移除软件组<br>
（只是删除本软件，不会删除依赖关系）	<br>
yum -y clean all                                                 //清除yum缓存列表（常用）                                  clean：去除                search：搜索，查找</p>
<p>yum -y  search   命令字		//查看某命令属于哪个软件包<br>
例：<br>
yum -y search finger<br>
yum -y search rpm<br>
yum -y search yum</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shell脚本的“判断语句”]]></title>
        <id>https://www.zhz666.cf/post/shell-jiao-ben-de-pan-duan-yu-ju/</id>
        <link href="https://www.zhz666.cf/post/shell-jiao-ben-de-pan-duan-yu-ju/">
        </link>
        <updated>2020-12-02T14:00:30.000Z</updated>
        <content type="html"><![CDATA[<p>【1】、条件测试</p>
<p>是判断语句最基础的算法，通过固定的格式进行字符串或数值的比较。<br>
语句格式中，【在中括号的两端加空格，测试语句不会直接生成结果】，满足条件的会标记为0，不满足条件的标记为其他值。</p>
<p>格式1：test  条件表达式<br>
格式2：[  条件表达式  ]             #两个空格都不能少</p>
<p>【2】、文件测试</p>
<p>通过条件表达式，测试指定的文件或目录是否存在或其属性。</p>
<p>条件判断<br>
判断的方式两种<br>
1、test<br>
2、if</p>
<p>test：文件测试<br>
格式1：test 表达式<br>
格式2：[   表达式    ]            #括号前后有空格</p>
<p>-d：是否是目录<br>
-f：是否是文件<br>
-r：是否具有读权限<br>
-w：是否具有写入权限<br>
-x：是否具有执行权限          Exist：存在，生存            excute：执行，实施<br>
-e：测试文件或目录是否存在<br>
-s：是否是套接字<br>
-c：是否是字符集设备<br>
-b：是否是是块设备<br>
$?   存储上一次命令执行后的状态，执行成功为0 ,执行失败或报错为其他数值</p>
<p>[root@lala ~]# test -d aaa<br>
[root@lala ~]# echo $?<br>
1                                            --返回1表示执行出错<br>
[root@lala ~]# mkdir aaa<br>
[root@lala ~]# test -d aaa<br>
[root@lala ~]# echo $?<br>
0</p>
<p>[root@lala ~]# [ -d /media/dvd  ]<br>
[root@lala ~]# echo $?<br>
0<br>
[root@lala ~]# [ -d /media/dvd/server  ]<br>
[root@lala ~]# echo $?<br>
1</p>
<p>[root@lala ~]# [ -d /media ] &amp;&amp; echo &quot;yes&quot;<br>
yes<br>
[root@lala ~]# [ -d /media/dvd ] &amp;&amp; echo &quot;yes&quot;             &amp;&amp;（逻辑与，而且的意思）<br>
因为没有/media/dvd目录，所以不输出任何结果<br>
[root@lala ~]#  [ -d /media/dvd ] &amp;&amp; echo &quot;yes&quot; || echo no     || （逻辑或，“或者”的意思）<br>
no<br>
[root@lala ~]# [ -f aa.txt ] &amp;&amp; echo &quot;yes&quot;<br>
[root@lala ~]# touch aa.txt<br>
[root@lala ~]# [ -f aa.txt ] &amp;&amp; echo &quot;yes&quot;<br>
yes</p>
<p>检查看aa.txt文件的权限                                   【友情提示：不要去用大管root用户测试权限】<br>
[root@lala ~]# ls -l aa.txt<br>
-rw-r--r--. 1 root root 0 3月   2 15:53 aa.txt<br>
[root@lala ~]# [ -r aa.txt ] &amp;&amp; echo &quot;yes&quot;    （读权限）<br>
yes<br>
[root@lala ~]# [ -w aa.txt ] &amp;&amp; echo &quot;yes&quot;   （写权限）<br>
yes<br>
[root@lala ~]# [ -x aa.txt ] &amp;&amp; echo &quot;yes&quot;   （执行权限）<br>
因为没有执行权限，所以不输出任何内容<br>
[haha@localhost huaizhe]$ [ -x aa.txt ] &amp;&amp; echo &quot;yes&quot;  || echo 你没有权限<br>
你没有权限</p>
<p>[root@lala ~]# [ -e aa.txt ] &amp;&amp; echo &quot;yes&quot;    （是否存在）<br>
yes<br>
[root@lala ~]# [ -e a.txt ] &amp;&amp; echo &quot;yes&quot;</p>
<p>【3】、整数值比较<br>
-eq：等于（Equal）         Equal：相同的，同等的                               greate：较大的        than：就，（多、小、少）于              lesser： 较小的<br>
-ne：不等于（Not Equal）<br>
-gt：大于（Greater Than）<br>
-lt：小于（Lesser Than）<br>
-le：小于或等于（Lesser or Equal）<br>
-ge：大于或等于（Greater or Equal）</p>
<p>[root@lala ~]# [ 1 -eq 2 ]<br>
[root@lala ~]# echo $?<br>
1-255<br>
[root@lala ~]# [ 1 -eq 1 ]<br>
[root@lala ~]# echo $?<br>
0</p>
<p>例：测试用户输入的值是否大于100<br>
例：（脚本）<br>
#!/bin/bash<br>
stty -echo<br>
read -p &quot;请输入一个数值：&quot; num<br>
printf &quot;\n&quot;<br>
stty echo<br>
printf &quot;\n&quot;<br>
[ $num -gt 100 ] &amp;&amp; echo &quot;数值大于100&quot; || echo &quot;数值小于100&quot;</p>
<p>例：判断磁盘使用量<br>
[root@lala ~]# df -hT<br>
文件系统            类型      容量  已用  可用 已用% 挂载点<br>
/dev/mapper/cl-root xfs        97G  4.1G   93G    5% /<br>
devtmpfs            devtmpfs  897M     0  897M    0% /dev<br>
tmpfs               tmpfs     912M  144K  912M    1% /dev/shm<br>
tmpfs               tmpfs     912M   17M  895M    2% /run<br>
tmpfs               tmpfs     912M     0  912M    0% /sys/fs/cgroup<br>
/dev/sda1           xfs       197M  150M   47M   77% /boot<br>
tmpfs               tmpfs     183M   16K  183M    1% /run/user/0<br>
/dev/sr0            iso9660   4.1G  4.1G     0  100% /media/dvd<br>
[root@lala ~]# df -hT | grep &quot;/boot<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 75: …t
[root@lala ~]#̲ df -hT | grep …'>&quot;
/dev/sda1           xfs       197M  150M   47M   77% /boot
[root@lala ~]# df -hT | grep &quot;/boot</span>&quot; | awk '{print <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 2: 6}̲&#039;
77%
[root@lal…'>6}&#039;
77%
[root@lala ~]# df -hT | grep &quot;/boot</span>&quot; | awk '{print $6}' | cut -d% -f1<br>
77<br>
[root@lala ~]# [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><mo>−</mo><mi>h</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(df -hT | grep &quot;/boot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord">&quot;</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>&quot; | awk '{print $6}' | cut -d% -f1) -ge 60 ] &amp;&amp; echo &quot;too many&quot;<br>
too many</p>
<p>例：判断内存<br>
[root@lala ~]# free<br>
total        used        free      shared  buff/cache   available<br>
Mem:        1867264      581368      324024       19444      961872     1033020<br>
Swap:       2097148           0     2097148<br>
[root@lala ~]# free | grep &quot;Mem:&quot;<br>
Mem:        1867264      581740      323652       19444      961872     1032680<br>
[root@lala ~]# free | grep &quot;Mem:&quot; | awk '{print <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 2: 4}̲&#039;
323388
[root@…'>4}&#039;
323388
[root@lala ~]# b=</span>(free | grep &quot;Mem:&quot; | awk '{print $4}')<br>
[root@lala ~]# [ $b -lt 500000 ] &amp;&amp; echo ${b}MB</p>
<p>【4】、字符串比较<br>
=:字符串相同<br>
!=：字符串不同（! 号表示相反的意思）<br>
-z：字符串是否为空</p>
<p>例：<br>
[root@lala ~]# echo $LANG<br>
zh_CN.UTF-8<br>
[root@lala ~]# [ $LANG != &quot;zh_CN.UTF-8&quot; ] &amp;&amp; echo &quot;不是中文&quot; || echo &quot;中文&quot;<br>
中文</p>
<p>例：<br>
[root@lala ~]# read -p &quot;Do you love me?(yes/no)&quot; ack<br>
Do you love me?(yes/no)yes<br>
[root@lala ~]# [ $ack = &quot;yes&quot; ] &amp;&amp; echo &quot;I love you too&quot; || echo &quot;But I love you very much&quot;<br>
I love you too<br>
[root@lala ~]# [ $ack = &quot;no&quot; ] &amp;&amp; echo &quot;I love you too&quot; || echo &quot;But I love you very much&quot;<br>
But I love you very much<br>
例：<br>
[root@localhost ~]# [ -z ]<br>
[root@localhost ~]# echo $?<br>
0<br>
[root@localhost ~]# [ -z 123456 ]<br>
[root@localhost ~]# echo $?<br>
1<br>
特殊示例：<br>
a=               {变量值不能为空}<br>
b=123.com<br>
[ $a = $b ]<br>
echo $?<br>
2<br>
[root@localhost ~]# [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">a=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>b ]        //不加空格相当等式了！！！<br>
[root@localhost ~]# echo $?<br>
0</p>
<p>【5】、逻辑测试<br>
-a或&amp;&amp;：逻辑与（and）         #多个测试条件进行链接，当前面的测试条件满足时，进行后面的条件测试<br>
-o或||    ：逻辑或/否则（or）  #多个测试条件满足任意一个（[ $a -lt 90 ] || [ $a -ge 80 ] ）<br>
！          ：逻辑非（取反）<br>
应用环境：||一般用于多个&amp;&amp;测试条件之后，当前面的测试都不满足时，最后默认生效的测试。<br>
num=101<br>
[ $num -gt 100 ] &amp;&amp; echo &quot;数值大于100&quot; || echo &quot;数值小于100&quot;</p>
<p>例：<br>
[root@lala ~]# [ $USER != root ] &amp;&amp; echo &quot;not root&quot; || echo &quot;hello good man&quot;<br>
hello good man<br>
[root@lala ~]# [ $USER = root ] &amp;&amp; echo &quot;hello muhuaijun is a good man&quot; || echo &quot;not root&quot;<br>
hello muhuaijun is a good man</p>
<p>例：判断用户是否存在<br>
[root@lala ~]# id<br>
uid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023<br>
[root@lala ~]# id abc<br>
id: abc: no such user<br>
写一个脚本，检查用户abc是否存在，如果存在，则显示“abc is user”，如果不存在则创建<br>
vim useradd.sh<br>
#!/bin/bash<br>
id abc &amp;&gt; /dev/null &amp;&amp; echo &quot;abc is user&quot; || useradd abc</p>
<p>[root@lala ~]# sh useradd.sh<br>
[root@lala ~]# tail -1 /etc/passwd<br>
abc：x：1001:1001::/home/abc:/bin/bash</p>
<h1 id="例rootlala-~-vim-diskshbinbashdiskuserdf-ht-grep-boot-awk-print-6-cut-d-f1-diskuser-ge-60-echo-space-is-low-echo-space-is-muchrootlala-~-sh-diskshspace-is-low例rootlocalhost-~-z-pass1-rootlocalhost-~-echo-1rootlocalhost-~-pass14566rootlocalhost-~-z-pass1-rootlocalhost-~-echo-0">例：<br>
[root@lala ~]# vim disk.sh<br>
#!/bin/bash<br>
diskuser=<code>df -hT | grep &quot;/boot$&quot; | awk '{print $6}' | cut -d% -f1</code><br>
[ $diskuser -ge 60 ] &amp;&amp; echo &quot;space is low&quot; || echo &quot;space is much&quot;<br>
[root@lala ~]# sh disk.sh<br>
space is low<br>
例：<br>
[root@localhost ~]# ! [ -z $pass1 ]<br>
[root@localhost ~]# echo $?<br>
1<br>
[root@localhost ~]# pass1=4566<br>
[root@localhost ~]# ! [ -z $pass1 ]<br>
[root@localhost ~]# echo $?<br>
0</h1>
<p><font color=#0000FF><strong>练习</strong></font></p>
<p>1、测试/opt/backup目录是否存在<br>
[root@lala ~]# vim di.sh<br>
#!/bin/bash<br>
[ -d /opt/backup ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</p>
<p>[root@lala ~]# sh di.sh<br>
no</p>
<p>2、查询当前的活动进程数，并测试是否小于100<br>
[root@lala ~]# vim ps.sh<br>
#!/bin/bash<br>
<font color="#dddd00">pss=$(ps aux | wc -l)</font><br /><br>
[ $pss -lt 100 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;<br>
[root@lala ~]# sh ps.sh<br>
no</p>
<p>3、测试是否已经安装sysstat软件包<br>
[root@lala ~]# vim sys.sh<br>
#!/bin/bash<br>
rpm -qa sysstat &amp;&gt; /dev/null<br>
<font color="#dddd00">a=$(echo $?)</font><br /><br>
[ $a -ne 0 ] &amp;&amp; echo &quot;not installed&quot; || echo &quot;installed&quot;</p>
<h1 id="4-测试user1是否存在若不存在则创建rootlala-~-vim-users2shbinbashid-user1-devnull-echo-有此用户-echo-正在创建此用户-useradd-user1-id-user10-devnull-useradd-user10-echo-user10-passwd-stdin-123com-devnull-echo-user10-shigeyonghu-id-user20-devnull-useradd-user20-echo-user20-passwd-stdin-123com-devnull-echo-user20-shigeyonghu-id-user30-devnull-useradd-user30-echo-user30-passwd-stdin-123com-devnull-echo-user30-shigeyonghu-id-user40-devnull-useradd-user40-echo-user40-passwd-stdin-123com-devnull-echo-user40-shigeyonghu-id-user50-devnull-useradd-user50-echo-user50-passwd-stdin-123com-devnull-echo-user50-shigeyonghu">4、测试user1是否存在，若不存在则创建<br>
[root@lala ~]# vim users2.sh<br>
#!/bin/bash<br>
id user1 &amp;&gt; /dev/null &amp;&amp; echo 有此用户 || echo 正在创建此用户 &amp;&amp; useradd user1<br>
! id user10 &amp;&gt; /dev/null &amp;&amp; useradd user10 &amp;&amp; echo &quot;user10&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user10 shigeyonghu&quot;<br>
! id user20 &amp;&gt; /dev/null &amp;&amp; useradd user20 &amp;&amp; echo &quot;user20&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user20 shigeyonghu&quot;<br>
! id user30 &amp;&gt; /dev/null &amp;&amp; useradd user30 &amp;&amp; echo &quot;user30&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user30 shigeyonghu&quot;<br>
! id user40 &amp;&gt; /dev/null &amp;&amp; useradd user40 &amp;&amp; echo &quot;user40&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user40 shigeyonghu&quot;<br>
! id user50 &amp;&gt; /dev/null &amp;&amp; useradd user50 &amp;&amp; echo &quot;user50&quot; | passwd --stdin &quot;123.com&quot; &amp;&gt; /dev/null || echo &quot;user50 shigeyonghu&quot;</h1>
<p>if语句结构<br>
if……then……：如果……那么……</p>
<p>每个if语句都要用fi结束，而且是每一个if都要对应一个fi。<br>
整个if语句用fi闭合起来才算完整，书写时if和fi要垂直对齐以方便查看。</p>
<p>格式举例：<br>
if  condition                                   condition：状态<br>
then<br>
    command1<br>
    command2                                command：命令，指令<br>
fi</p>
<p>condition是判断条件，如果 condition 成立（返回“真”），那么 then 后边的语句将会被执行；如果 condition 不成立（返回“假”），那么不会执行任何语句。最后必须以fi来闭合，fi 就是 if 倒过来拼写，即使有多条语句也不需要用{ }包围起来。</p>
<p><font color="#00dd00"><strong>【1】单分支语法格式（两种写法）</strong></font><br /><br>
if  条件测试操作	                              	if  条件测试操作；then 命令序列<br>
then 命令序列    	                             	      fi<br>
fi<br>
解析：【1】如果if和then在同一行，必有;       【2】不在一行;可以省略！！！<br>
<font color="#dd0000">单分支执行流程：<br>
1）首先判断条件测试操作的结果。<br>
2）如果返回值为0，表示条件成立，则执行then后面的命令序列，一直到遇见fi结束判断为止，继续执行其他脚本代码；<br>
3）如果返回值不为0，则忽略then后面的命令序列，直接跳转至fi行以后执行其他脚本代码。</font><br /></p>
<p>例：<br>
[root@localhost ~]# vim mount.sh<br>
#!/bin/bash<br>
mou=&quot;/var/www/html&quot;<br>
if [ ! -d $mou ]<br>
then<br>
mkdir -p $mou<br>
fi</p>
<p>例：<br>
[root@localhost ~]# vim us.sh<br>
#!/bin/bash<br>
if [ $USER != &quot;abc&quot; ]<br>
then<br>
echo &quot;abc is not user&quot;                //执行脚本，返回abc is not user（如果有abc用户，将什么都不显示！）<br>
fi<br>
<font color="#00dd00"><strong>【2】双分支语法格式</strong></font><br /><br>
判断条件表达式中的结果是否满足，如果满足条件则执行命令序列1，如果不满足条件，则执行命令序列2。</p>
<p>语法格式：<br>
if [ 条件测试操作 ];then                                                                      then：接着，当时                else：其他的，另外的<br>
满足条件后执行的语句 （命令序列1）<br>
else<br>
不满足添加后执行的语句（命令序列2）<br>
fi<br>
<font color="#dd0000"><strong>注：else在一组if语句中只能使用一次。<br>
在程序或脚本中，大部分的逻辑判断都是使用双分支语句。</strong></font><br /><br>
<font color="#dd0000">执行流程：</br><br>
1）首先判断条件测试操作的结果！</br><br>
2）如果条件成立，则执行then后面的命令序列1，忽略else及后面的命令序列2，直到遇见fi结束判断；</br><br>
3）如果条件不成立，则忽略then及后面的命令序列1，直接跳至else后面的命令序列2，直到遇见fi结束判断。</font><br /></p>
<p>例：<br>
[root@localhost www]# vim httpd.sh<br>
#!/bin/bash<br>
netstat -anpt | grep 80<br>
a=<code>echo $?</code><br>
if [ $a -eq 0 ];then<br>
echo &quot;httpd is running&quot;<br>
else<br>
systemctl restart httpd &amp;&amp; echo &quot;httpd is run!!!&quot;<br>
fi</p>
<p>例：<br>
[root@localhost www]# vim ping.sh<br>
#!/bin/bash<br>
ping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/null<br>
if [ $? -eq 0 ]<br>
then<br>
echo &quot;host $1 is up&quot;<br>
else<br>
echo &quot;host $1 is down&quot;<br>
fi</p>
<p>-c    3:只发送3个测试包<br>
-i    0.2：间隔0.2秒<br>
-W     3：超时3秒<br>
$1：位置变量，如果改成$2，则要写两个ip地址，第一个不被使用，直接使用第二个</p>
<p>[root@localhost www]# chmod +x ping.sh<br>
[root@localhost www]# ./ping.sh 192.168.6.20</p>
<p><font color="#00dd00"><strong>【3】多分支语句结构</strong></font><br /><br>
判断条件中，多于两个以上的对比值，使用多分支判断，对不用值的语句调用。<br>
if  条件测试操作1<br>
then 命令序列1<br>
elif 条件测试操作2                               elif：否则如果<br>
then 命令序列2<br>
else  命令序列3<br>
fi<br>
<font color="#dd0000">执行流程：</br><br>
1）首先判断条件测试操作1的结果，如果条件1成立，则执行命令序列1，然后跳至fi结束判断；</br><br>
2）如果条件1不成立，则继续判断条件测试操作2的结果，如果条件2成立，则执行命令序列2，然后跳至fi结束判断……0</br><br>
3）如果所有条件都不满足，则执行then及后面的命令序列n，直接跳至else后面的命令序列2，直到遇见fi结束判断。</td></tr></font><br /></p>
<p>例：<br>
vim name.sh<br>
#!/bin/bash<br>
read -p &quot;what's your name?(xuesenwei,lianpeng,yuxinyu,boge):&quot;  name<br>
if [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>x</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>w</mi><mi>e</mi><mi>i</mi><mi mathvariant="normal">&quot;</mi><mo>]</mo><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">name = &quot;xuesenwei&quot; ]
then
echo &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mord mathdefault">x</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>name is pig&quot;<br>
elif [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>l</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">&quot;</mi><mo>]</mo><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">name = &quot;lianpeng&quot; ]
then
echo &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>name is monkey&quot;<br>
elif [ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>y</mi><mi>u</mi><mi>x</mi><mi>i</mi><mi>n</mi><mi>y</mi><mi>u</mi><mi mathvariant="normal">&quot;</mi><mo>]</mo><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">name = &quot;yuxinyu&quot; ]
then
echo &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">u</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">u</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>name is dashu&quot;<br>
else<br>
echo &quot;$name is niu&quot;<br>
fi</p>
<p>[root@lala ~]# sh name.sh<br>
what's your name?(xuesenwei,lianpeng,yuxinyu,boge):yuxinyu<br>
yuxinyu is dashu</p>
<p>例：<br>
[root@lala ~]# vim fen.sh           --书上的示例<br>
#!/bin/bash<br>
read -p &quot;qing shu ru nin de fen shu(0-100):&quot;    fenshu<br>
if<br>
[ $fenshu -ge 85 ] &amp;&amp; [ $fenshu -le 100 ];<br>
then<br>
echo &quot;chengji is couhe&quot;<br>
elif<br>
[ $fenshu -ge 70 ] &amp;&amp; [ $fenshu -le 84 ];<br>
then<br>
echo &quot;chengji is youxiu&quot;<br>
elif<br>
[ $fenshu -ge 60 ] &amp;&amp; [ $fenshu -le 69 ];<br>
then<br>
echo &quot;chengji is hege&quot;<br>
else<br>
echo &quot;chengji is bujige&quot;<br>
fi</p>
<h2 id="rootlala-~-sh-fenshqing-shu-ru-nin-de-fen-shu0-10085chengji-is-couherootlala-~-sh-fenshqing-shu-ru-nin-de-fen-shu0-10074chengji-is-youxiu">[root@lala ~]# sh fen.sh<br>
qing shu ru nin de fen shu(0-100):85<br>
chengji is couhe<br>
[root@lala ~]# sh fen.sh<br>
qing shu ru nin de fen shu(0-100):74<br>
chengji is youxiu</h2>
<p><font size="4"><strong>判断分数范围，分出优秀、合格、不合格三档（中文版）</strong></font><br>
<font color="#0000dd"><br>
#!/bin/bash<br>
read -p 请输入成绩： a<br>
if [ $a -le 100 ] &amp;&amp;  [ $a -ge 90 ]<br>
then   echo 优<br>
elif [ $a -lt 90 ] &amp;&amp; [ $a -ge 80 ]<br>
then echo 良<br>
elif [ $a -lt 80 ] &amp;&amp; [ $a -ge 70 ]; then<br>
echo 好<br>
elif [ $a -lt 70 ] &amp;&amp; [ $a -ge 60 ];then echo 合格<br>
elif [ $a -ge 100 ];<br>
then echo 你牛逼<br>
else<br>
echo 不合格<br>
fi<br>
[root@localhost ~]# source 1.sh<br>
请输入成绩：105<br>
你牛逼<br>
[root@localhost ~]# source 1.sh<br>
请输入成绩：35<br>
不合格<br>
[root@localhost ~]# source 1.sh<br>
请输入成绩：85<br>
良</font><br /></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7安装VMware-Tools]]></title>
        <id>https://www.zhz666.cf/post/centos7-an-zhuang-vmware-tools/</id>
        <link href="https://www.zhz666.cf/post/centos7-an-zhuang-vmware-tools/">
        </link>
        <updated>2020-11-24T00:24:02.000Z</updated>
        <content type="html"><![CDATA[<p>1、配置yum源😎<br>
rm -f /etc/yum.repos.d/*<br>
vim /etc/yum.repos.d/yum.repo</p>
<p>2、挂载系统光盘<br>
umount /dev/sr0<br>
mount /dev/sr0 /media<br>
cd /media/Packages/</p>
<p>3、安装组件与依赖关系<br>
yum -y install gcc gcc-c++ perl make kernel-haders kernel-devel</p>
<p>4、卸载系统自带工具<br>
rpm -qa | grep vm-tools<br>
rpm -e open-vm-tools open-vm-tools-desktop --nodeps</p>
<p>5、建立内核版本文件软连接文件<br>
ln -s /usr/src/kernels/3.10.0-514.el7.x86_64/include/generated/uapi/linux/version.h /usr/src/kernels/3.10.0-514.el7.x86_64/include/linux/version.h</p>
<p>6、关闭防火墙与selinux<br>
vim /etc/selinux/config<br>
修改：<br>
SELINUX=disabled</p>
<p>setenforce 0<br>
systemctl disable firewalld.service<br>
systemctl stop firewalld.service<br>
reboot</p>
<p>7、挂载vmware-tools光盘，解压软，并安装软件<br>
tar -zxvf VMwareTools-10.0.0-2977863.tar.gz -C /tmp<br>
cd /tmp/vmware-tools-distrib/<br>
./vmware-install.pl<br>
reboot<br>
😎😎😎😎😎😎😎😎😎😎😎</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=442314991&auto=1&height=66"></iframe>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的世界]]></title>
        <id>https://www.zhz666.cf/post/wo-de-shi-jie/</id>
        <link href="https://www.zhz666.cf/post/wo-de-shi-jie/">
        </link>
        <updated>2020-11-15T05:36:15.000Z</updated>
        <content type="html"><![CDATA[<iframe  class="music" frameborder="no" src="//music.163.com/outchain/player?type=1&id=89680147&auto=1&height=90"></iframe>
>en						用户模式
#conf t						特权模式
(config)#int f0/0					全局模式
(config-if)#					接口模式
#disable  →>
(config)#hostname  name				修改主机名
<p>switch(config)#vlan vlan-number			划分VLAN<br>
switch(config-vl)#name vlan-name			vlan命名<br>
switch(config)#int range f0/1-5			同时进入f0/1-5端口<br>
Switch(config-if-range)#switchport mode access		把端口设置成接入链路<br>
Switch(config-if-range)#switchport access vlan 2		把端口加入到vlan2<br>
switch(config-if-range)#switchport mode trunk		把端口设置成中继链路<br>
switch(config-if-range)#channel-group 1 mode on 	把几个端口捆绑成以太网通道1<br>
switch(config)#vtp domain vtp-name			设置VTP名称<br>
switch(config)#vtp password vtp-password		设置VTP密码<br>
switch(config)#vtp mode server|client			设置成VTP服务器|客户端<br>
switch(config)#ip default-gateway 默认网关		设置交换机默认网关	<br>
(config)#enable secret pwd1				设置特权模式密码(密文)<br>
(config)#enable password pwd1			设置特权模式密码(明文)<br>
(config)#service password-encryption			对明文密码加密<br>
(config-if)#ip address IP地址 子网掩码 			设置IP地址(交换机的IP地址只能设置在虚拟端口vlan上)<br>
(config-if)#no shutdown				手动开启端口<br>
(config)#line vty 0 4				开启0~4端口(一共5个)<br>
(config)#password vty-password			设置vty密码<br>
(config)#login					开启登录模式<br>
(config)#line console 0 				进入配置口<br>
(config)#password con-password			设置配置口密码<br>
(config)#login					开启登录模式<br>
vty		远程访问的时候需要<br>
console		直接用配置线对设备配置时需要<br>
router(config)#ip route 目标网段 子网掩码 IP地址|端口号 num	设置静态路由<br>
router(config)#ip route 192.168.6.0 255.255.255.0 f0/1<br>
IP地址指向下一个路由器(下一个路由器接收口的IP地址)<br>
端口号指自身的端口(当前路由器的出口)<br>
num数值1~255  数值越小优先级越高<br>
目标网段 不能是具体IP地址(192.168.10.0      2.0.0.0)<br>
router(config)#ip dhcp pool dhcp-name		设置DHCP并命名<br>
router(dhcp-config)#network 分配的网段 子网掩码		设置地址池<br>
分配的网段  (192.168.5.0  6.0.0.0)<br>
router(dhcp-config)#default-router 默认网关		DHCP分配的默认网关<br>
router(config)#int f 0/0.1				进入子端口<br>
f0/0.1指 f0/0的第一个子端口<br>
f0/1.2指 f0/1的第二个子端口<br>
Router(config-subif)#en do vlan-number		把子端口绑定到vlan<br>
Router(config-subif)#en do 2				把子端口绑定到vlan2</p>
<p>telnet 目标IP地址					PC上远程访问设备<br>
#reload						正常使用时重启<br>
#show running-config				查看运行时配置<br>
#show startup-config				查看保存的配置<br>
(config)#do show running-config			其他模式下查看前面+do</p>
<p>#copy running-config startup-config			把当前配置保存到NVRAM<br>
#write						保存运行时配置(效果同上)<br>
#copy startup-config running-config			用NVRAM覆盖当前配置</p>
<p>#erase nvram: 					删除保存的配置</p>
<p>#copy tftp flash					从TFTP服务器下载系统到路由器	<br>
#copy flash tftp					从路由器上传系统到服务器<br>
(config)#ip ftp username s1t161			在路由器上设置ftp的用户名<br>
(config)#ip ftp password s1t161			在路由器上设置ftp的密码</p>
<p>rommon 1 &gt; tftpdnld     				(download)<br>
rommon 2 &gt; IP_ADDRESS=1.1.1.1			设置路由器的IP地址<br>
rommon 3 &gt; IP_SUBNET_MASK=255.0.0.0		设置路由器的子网掩码<br>
rommon 4 &gt; DEFAULT_GATEWAY=1.2.2.2		设置路由器的默认网关(TFTP的IP地址)<br>
rommon 5 &gt; TFTP_SERVER=1.2.2.2			设置下载系统的原位置的IP地址(TFTP的IP地址)<br>
rommon 6 &gt; TFTP_FILE=c1841-ipbasek9-mz.124-12.bin	设置要下载的文件名<br>
rommon 7 &gt; tftpdnld</p>
<p>Do you wish to continue? y/n:  [n]:  y			输入y继续<br>
rommon 8 &gt; reset					重启<br>
😙</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://www.zhz666.cf/post/hello-gridea/</id>
        <link href="https://www.zhz666.cf/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>